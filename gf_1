-- ============================================================================
-- FLASHY THEME INTEGRATION
-- ============================================================================

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local SoundService = game:GetService("SoundService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local Assets = {
    Sounds = {
        Click = "rbxassetid://6895079853",
        Hover = "rbxassetid://6895079775",
        Notification = "rbxassetid://4590662766",
        Success = "rbxassetid://6895079853",
        Error = "rbxassetid://4590657391",
        Whoosh = "rbxassetid://1177785010",
        PowerUp = "rbxassetid://5153734944"
    }
}

local FX = {
    audioEnabled = true,
    hapticEnabled = true,
    particlesEnabled = true
}

function FX:Sound(id, vol, pitch)
    if not self.audioEnabled then return end
    task.spawn(function()
        local s = Instance.new("Sound")
        s.SoundId = id
        s.Volume = vol or 0.5
        s.PlaybackSpeed = pitch or 1
        s.Parent = SoundService
        s:Play()
        s.Ended:Wait()
        s:Destroy()
    end)
end



function FX:Click()
    self:Sound(Assets.Sounds.Click, 0.4, 1)
end

function FX:Hover()
    self:Sound(Assets.Sounds.Hover, 0.25, 1.3)
end

function FX:Success()
    self:Sound(Assets.Sounds.Success, 0.6, 1.1)
end

function FX:Notify()
    self:Sound(Assets.Sounds.Notification, 0.5, 1)
end

local Style = {}

function Style:Accent(text)
    return "<b><font color='#ff91af'>" .. text .. "</font></b>"
end

local NebulaStorm = {
    TextColor = Color3.fromRGB(245, 240, 255),
    PlaceholderColor = Color3.fromRGB(135, 125, 155),
    Background = Color3.fromRGB(10, 8, 18),
    Topbar = Color3.fromRGB(16, 13, 28),
    Shadow = Color3.fromRGB(4, 2, 8),
    NotificationBackground = Color3.fromRGB(18, 15, 30),
    NotificationActionsBackground = Color3.fromRGB(26, 22, 40),
    TabBackground = Color3.fromRGB(22, 18, 35),
    TabStroke = Color3.fromRGB(55, 45, 75),
    TabBackgroundSelected = Color3.fromRGB(255, 145, 175),
    TabTextColor = Color3.fromRGB(245, 240, 255),
    SelectedTabTextColor = Color3.fromRGB(10, 8, 18),
    ElementBackground = Color3.fromRGB(18, 15, 30),
    ElementBackgroundHover = Color3.fromRGB(30, 25, 45),
    SecondaryElementBackground = Color3.fromRGB(14, 11, 24),
    ElementStroke = Color3.fromRGB(65, 55, 90),
    SecondaryElementStroke = Color3.fromRGB(50, 40, 70),
    SliderBackground = Color3.fromRGB(28, 24, 42),
    SliderProgress = Color3.fromRGB(255, 145, 175),
    SliderStroke = Color3.fromRGB(75, 65, 100),
    ToggleBackground = Color3.fromRGB(18, 15, 30),
    ToggleEnabled = Color3.fromRGB(255, 145, 175),
    ToggleDisabled = Color3.fromRGB(55, 45, 70),
    ToggleEnabledStroke = Color3.fromRGB(255, 165, 195),
    ToggleDisabledStroke = Color3.fromRGB(40, 30, 55),
    ToggleEnabledOuterStroke = Color3.fromRGB(75, 65, 95),
    ToggleDisabledOuterStroke = Color3.fromRGB(32, 22, 48),
    DropdownSelected = Color3.fromRGB(32, 27, 48),
    DropdownUnselected = Color3.fromRGB(18, 15, 30),
    InputBackground = Color3.fromRGB(18, 15, 30),
    InputStroke = Color3.fromRGB(65, 55, 90)
}

-- ============================================================================
-- ORIGINAL CODE START
-- ============================================================================

local HttpService = game:GetService('HttpService')
local Players = game:GetService('Players')
local LocalPlayer = Players.LocalPlayer
local urls = {
    'https://raw.githubusercontent.com/Nahalliaa/CasualComas/refs/heads/main/P1.luau',
    'https://raw.githubusercontent.com/Nahallia/Cc/refs/heads/main/Part2.luau',
    'https://raw.githubusercontent.com/Nahalliaa/CasualComas/refs/heads/main/CarMods',
}

for _, url in ipairs(urls)do
    loadstring(game:HttpGet(url))()
end



-- Enhanced UI styling with Flashy Theme
task.spawn(function()
    task.wait(1)

    local function findRayfield()
        for _, gui in ipairs(CoreGui:GetChildren())do
            local rf = gui:FindFirstChild('Rayfield')
            if rf then
                return rf
            end
        end
    end
    
    local function apply()
        local rayfield = findRayfield()

        if not rayfield then
            return
        end

        local prompt = rayfield:FindFirstChild('Prompt')

        if not prompt then
            return
        end
        
        -- Apply Nebula Storm theme colors
        if prompt:IsA('Frame') or prompt:IsA('TextButton') or prompt:IsA('ImageButton') then
            prompt.BackgroundColor3 = NebulaStorm.Background
        end

        local title = prompt:FindFirstChild('Title')

        if title and title:IsA('TextLabel') then
            title.Text = Style:Accent('Casual Comas')
            title.TextColor3 = NebulaStorm.TextColor
            title.RichText = true
        end
    end

    apply()

    while task.wait(1.5) do
        apply()
    end
end)

-- Enhanced UI interactions with audio and hover effects
task.spawn(function()
    while task.wait(0.5) do
        local gui = CoreGui:FindFirstChild("Rayfield")
        if not gui then continue end
        for _, v in pairs(gui:GetDescendants()) do
            if (v:IsA("TextLabel") or v:IsA("TextButton")) then
                v.RichText = true
            end
            if v:IsA("TextButton") and not v:GetAttribute("Enhanced") then
                v:SetAttribute("Enhanced", true)
                v.MouseEnter:Connect(function()
                    FX:Hover()
                    TweenService:Create(v, TweenInfo.new(0.2), {
                        BackgroundColor3 = NebulaStorm.ElementBackgroundHover
                    }):Play()
                end)
                v.MouseLeave:Connect(function()
                    TweenService:Create(v, TweenInfo.new(0.2), {
                        BackgroundColor3 = NebulaStorm.ElementBackground
                    }):Play()
                end)
                v.MouseButton1Down:Connect(function()
                    TweenService:Create(v, TweenInfo.new(0.1), {
                        Size = v.Size * 0.97
                    }):Play()
                end)
                v.MouseButton1Up:Connect(function()
                    TweenService:Create(v, TweenInfo.new(0.1), {
                        Size = v.Size / 0.97
                    }):Play()
                end)
            end
        end
    end
end)

-- Global click sound effect
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        FX:Click()
    end
end)

local Env = getgenv().PL_Hub

if not Env then
    return warn('Load Part 1 First!')
end

local HttpService = Env.Services.HttpService
local ReplicatedStorage = Env.Services.ReplicatedStorage
local Players = Env.Services.Players
local LocalPlayer = Players.LocalPlayer
local RunService = Env.Services.RunService
local Workspace = game:GetService('Workspace')

-- Auto Reload Settings
local AutoReload_Settings = {
    enabled = false,
    instant_reload = false,
    reload_time = 0.01,  -- Instant reload (0.01 seconds)
    auto_reload_threshold = 5,  -- Auto reload when ammo <= this
}

local AutoReload_Connections = {}

-- ============================================================================
-- INSTANT RELOAD IMPLEMENTATION (Modifies gun stats)
-- ============================================================================

-- Hook the gun stats to modify reload time
local function SetupInstantReload()
    -- Method 1: Hook GetAttributes metamethod
    if hookmetamethod then
        local namecall
        namecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            
            if method == "GetAttributes" then
                local result = namecall(self, ...)
                
                if result and typeof(result) == "table" and AutoReload_Settings.instant_reload then
                    -- Modify reload time for all guns
                    if result.ReloadTime then
                        result.ReloadTime = AutoReload_Settings.reload_time
                    end
                end
                
                return result
            end
            
            return namecall(self, ...)
        end)
    end
    
    -- Method 2: Continuously modify GunStates module
    AutoReload_Connections.InstantReload = RunService.Heartbeat:Connect(function()
        pcall(function()
            if not AutoReload_Settings.instant_reload then return end
            
            -- CRITICAL: Check if character exists and is valid
            local character = LocalPlayer.Character
            if not character or not character.Parent then return end
            
            -- Check equipped tool
            local tool = character:FindFirstChildOfClass("Tool")
            if tool and tool:FindFirstChild("GunStates") then
                local gunStates = tool.GunStates
                local success, gunModule = pcall(require, gunStates)
                
                if success and type(gunModule) == "table" then
                    -- Modify reload time
                    if gunModule.ReloadTime then
                        gunModule.ReloadTime = AutoReload_Settings.reload_time
                    end
                end
            end
            
            -- Also modify guns in backpack
            local backpack = LocalPlayer.Backpack
            if backpack and backpack.Parent then
                local backpackTools = backpack:GetChildren()
                if backpackTools then
                    for _, backpackTool in pairs(backpackTools) do
                        if backpackTool and backpackTool:IsA("Tool") and backpackTool:FindFirstChild("GunStates") then
                            local gunStates = backpackTool.GunStates
                            local success, gunModule = pcall(require, gunStates)
                            
                            if success and type(gunModule) == "table" then
                                if gunModule.ReloadTime then
                                    gunModule.ReloadTime = AutoReload_Settings.reload_time
                                end
                            end
                        end
                    end
                end
            end
        end)
    end)
end

-- ============================================================================
-- AUTO RELOAD IMPLEMENTATION (Triggers reload automatically)
-- ============================================================================

local function SetupAutoReload()
    AutoReload_Connections.AutoReload = RunService.Heartbeat:Connect(function()
        pcall(function()
            if not AutoReload_Settings.enabled then return end
            
            -- CRITICAL: Check if character exists and is valid
            local character = LocalPlayer.Character
            if not character or not character.Parent then return end
            
            -- Check equipped tool
            local tools = character:GetChildren()
            if not tools then return end
            
            for _, tool in pairs(tools) do
                if tool and tool:IsA("Tool") and tool:FindFirstChild("GunStates") then
                    local currentAmmo = tool:GetAttribute("Local_CurrentAmmo") or tool:GetAttribute("CurrentAmmo")
                    
                    if currentAmmo and currentAmmo <= AutoReload_Settings.auto_reload_threshold then
                        -- Trigger reload
                        local gunRemotes = ReplicatedStorage:FindFirstChild("GunRemotes")
                        if gunRemotes then
                            local funcReload = gunRemotes:FindFirstChild("FuncReload")
                            if funcReload then
                                funcReload:InvokeServer()
                            end
                        end
                    end
                end
            end
        end)
    end)
end

-- ============================================================================
-- INFINITE AMMO IMPLEMENTATION (Never runs out)
-- ============================================================================

local InfiniteAmmo_Enabled = false

local function SetupInfiniteAmmo()
    AutoReload_Connections.InfiniteAmmo = RunService.Heartbeat:Connect(function()
        pcall(function()
            if not InfiniteAmmo_Enabled then return end
            
            -- CRITICAL: Check if character exists and is valid
            local character = LocalPlayer.Character
            if not character or not character.Parent then return end
            
            -- Equipped guns
            local tools = character:GetChildren()
            if tools then
                for _, tool in pairs(tools) do
                    if tool and tool:IsA("Tool") and tool:FindFirstChild("GunStates") then
                        -- Get max ammo from GunStates module
                        local gunStates = tool.GunStates
                        local success, gunModule = pcall(require, gunStates)
                        
                        if success and type(gunModule) == "table" then
                            local maxAmmo = gunModule.MaxAmmo or 30
                            
                            -- Set ammo to max
                            tool:SetAttribute("Local_CurrentAmmo", maxAmmo)
                            tool:SetAttribute("StoredAmmo", 999)
                        end
                    end
                end
            end
            
            -- Backpack guns
            local backpack = LocalPlayer.Backpack
            if backpack and backpack.Parent then
                local backpackTools = backpack:GetChildren()
                if backpackTools then
                    for _, tool in pairs(backpackTools) do
                        if tool and tool:IsA("Tool") and tool:FindFirstChild("GunStates") then
                            local gunStates = tool.GunStates
                            local success, gunModule = pcall(require, gunStates)
                            
                            if success and type(gunModule) == "table" then
                                local maxAmmo = gunModule.MaxAmmo or 30
                                tool:SetAttribute("Local_CurrentAmmo", maxAmmo)
                                tool:SetAttribute("StoredAmmo", 999)
                            end
                        end
                    end
                end
            end
        end)
    end)
end

-- ============================================================================
-- CONTROL FUNCTIONS
-- ============================================================================

local function StartAutoReload()
    if AutoReload_Connections.AutoReload then
        pcall(function()
            if typeof(AutoReload_Connections.AutoReload) == "RBXScriptConnection" then
                AutoReload_Connections.AutoReload:Disconnect()
            end
        end)
        AutoReload_Connections.AutoReload = nil
    end
    
    if AutoReload_Settings.enabled then
        SetupAutoReload()
    end
end

local function StartInstantReload()
    if AutoReload_Connections.InstantReload then
        pcall(function()
            if typeof(AutoReload_Connections.InstantReload) == "RBXScriptConnection" then
                AutoReload_Connections.InstantReload:Disconnect()
            end
        end)
        AutoReload_Connections.InstantReload = nil
    end
    
    if AutoReload_Settings.instant_reload then
        SetupInstantReload()
    end
end

local function StartInfiniteAmmo()
    if AutoReload_Connections.InfiniteAmmo then
        pcall(function()
            if typeof(AutoReload_Connections.InfiniteAmmo) == "RBXScriptConnection" then
                AutoReload_Connections.InfiniteAmmo:Disconnect()
            end
        end)
        AutoReload_Connections.InfiniteAmmo = nil
    end
    
    if InfiniteAmmo_Enabled then
        SetupInfiniteAmmo()
    end
end

local function StopAllAmmoFeatures()
    for name, connection in pairs(AutoReload_Connections) do
        if connection and typeof(connection) == "RBXScriptConnection" then
            pcall(function()
                connection:Disconnect()
            end)
        end
    end
    AutoReload_Connections = {}
end

-- Handle character death/removal to prevent crashes
LocalPlayer.CharacterRemoving:Connect(function()
    -- Temporarily disable features when character is being removed
    pcall(function()
        local wasAutoReloadEnabled = AutoReload_Settings.enabled
        local wasInstantReloadEnabled = AutoReload_Settings.instant_reload
        local wasInfiniteAmmoEnabled = InfiniteAmmo_Enabled
        
        -- Disable all features
        AutoReload_Settings.enabled = false
        AutoReload_Settings.instant_reload = false
        InfiniteAmmo_Enabled = false
        
        -- Clean up connections
        StopAllAmmoFeatures()
        
        -- Re-enable after character is added
        task.wait(0.5)
        LocalPlayer.CharacterAdded:Wait()
        task.wait(0.5)
        
        -- Restore previous states
        AutoReload_Settings.enabled = wasAutoReloadEnabled
        AutoReload_Settings.instant_reload = wasInstantReloadEnabled
        InfiniteAmmo_Enabled = wasInfiniteAmmoEnabled
        
        -- Restart features
        if wasAutoReloadEnabled then StartAutoReload() end
        if wasInstantReloadEnabled then StartInstantReload() end
        if wasInfiniteAmmoEnabled then StartInfiniteAmmo() end
    end)
end)



-- Anti Features State Variables
local AntiFeatures_Enabled = {
    AntiAFK = true,      -- Auto-enabled
    AntiVoid = true,     -- Auto-enabled  
    AntiPunch = false,   -- Toggle in UI
    AutoRespawn = false, -- Toggle in UI
    AntiTase = false,    -- Toggle in UI
}

local AntiFeatures_Connections = {}

-- Hostile animations list (punch animations)
local HostileAnimations = {
    "rbxassetid://484200742",
    "rbxassetid://484926359",
    "rbxassetid://275012308",
    "rbxassetid://218504594"
}

-- ============================================================================
-- ANTI-AFK IMPLEMENTATION
-- ============================================================================
-- Automatically prevents being kicked for inactivity

AntiFeatures_Connections.AntiAFK = LocalPlayer.Idled:Connect(function()
    pcall(function()
        local VirtualUser = game:GetService("VirtualUser")
        VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
        wait(1)
        VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    end)
end)

-- ============================================================================
-- ANTI-VOID IMPLEMENTATION  
-- ============================================================================
-- Automatically teleports you up when falling into the void

AntiFeatures_Connections.AntiVoid = RunService.Stepped:Connect(function()
    if AntiFeatures_Enabled.AntiVoid then
        pcall(function()
            local lroot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if lroot and lroot.Position.Y < 1 then
                -- Unsit if sitting
                if LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character.Humanoid.Sit then
                    LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Running)
                end
                
                -- Teleport up to safe height
                lroot.CFrame = CFrame.new(
                    Vector3.new(lroot.Position.X, 169, lroot.Position.Z),
                    Vector3.new(lroot.Position.X, 169, lroot.Position.Z) + lroot.CFrame.LookVector
                )
                lroot.Velocity = Vector3.new(0, 0, 0)
            end
        end)
    end
end)

-- ============================================================================
-- ANTI-PUNCH IMPLEMENTATION
-- ============================================================================
-- Automatically kills players who try to punch you

AntiFeatures_Connections.AntiPunch = RunService.Heartbeat:Connect(function()
    if AntiFeatures_Enabled.AntiPunch then
        pcall(function()
            if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")) then
                return
            end
            
            local LHead = LocalPlayer.Character.Head
            
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
                    local VHumanoid = player.Character.Humanoid
                    
                    if VHumanoid.Health ~= 0 then
                        local VHead = player.Character:FindFirstChild("Head")
                        
                        if VHead and LHead then
                            -- Check if player is within punch range (5 studs)
                            if (VHead.Position - LHead.Position).Magnitude <= 5 then
                                -- Check if player is playing a punch animation
                                for _, animTrack in ipairs(VHumanoid:GetPlayingAnimationTracks()) do
                                    if table.find(HostileAnimations, animTrack.Animation.AnimationId) then
                                        -- Kill the attacker by firing melee event multiple times
                                        for i = 1, 15 do
                                            ReplicatedStorage.meleeEvent:FireServer(player)
                                        end
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
    end
end)

-- ============================================================================
-- CLEANUP FUNCTION (Optional - for disabling features)
-- ============================================================================

-- ============================================================================
-- AUTO RESPAWN IMPLEMENTATION
-- ============================================================================
-- Automatically respawns player after death and returns them to death location

local AutoRespawnSettings = { autorespawn = false, autoguns = false }
if not _G.TeamCooldown then _G.TeamCooldown = 0 end
if not _G.CanQuickRespawn then _G.CanQuickRespawn = true end
local tring, fugging = false, false
local cd_dur = 10
local coolingdown = false
local lastDeathCFrame = nil
local autoRespawnSetup = false
local StarterGui = game:GetService("StarterGui")
local Teams = game:GetService("Teams")

local function Notify(text, time)
    pcall(function()
        StarterGui:SetCore("SendNotification", { Title = "AutoRespawn"; Text = text; Duration = time or 2; })
    end)
end

local function fixcam()
    pcall(function()
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
        if Workspace:FindFirstChild("Camera") then
            Workspace.Camera.CameraType = Enum.CameraType.Custom
        end
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                Workspace.Camera.CameraSubject = humanoid
            end
        end
    end)
end

function _G.ResetCooldown()
    if not coolingdown then
        coolingdown = true
        _G.CanQuickRespawn = false
        task.wait(cd_dur)
        _G.CanQuickRespawn = true
        coolingdown = false
    end
end

local function getTeamEvent()
    local ok, remotes = pcall(function() return ReplicatedStorage:FindFirstChild("Remotes") end)
    if not ok or not remotes then return nil end
    local ok2, ev = pcall(function() return remotes:FindFirstChild("RequestTeamChange") end)
    if not ok2 then return nil end
    return ev
end

local TeamEvent = getTeamEvent()

local function setupAutoRespawn()
    if autoRespawnSetup then return end
    autoRespawnSetup = true
    
    LocalPlayer.CharacterAdded:Connect(function(char)
        local hrp = char:WaitForChild("HumanoidRootPart", 10)
        local hum = char:WaitForChild("Humanoid", 10)
        
        if lastDeathCFrame then
            if AutoRespawnSettings.autoguns then
            else
                task.wait(0.1)
                if hrp and lastDeathCFrame then 
                    pcall(function() hrp.CFrame = lastDeathCFrame end) 
                end
            end
        end
        
        if hum then
            hum.Died:Connect(function()
                if not AntiFeatures_Enabled.AutoRespawn then return end
                
                if hrp then lastDeathCFrame = hrp.CFrame end
                
                if TeamEvent then
                    if _G.CanQuickRespawn and os.time() >= _G.TeamCooldown then
                        _G.CanQuickRespawn = false
                        task.spawn(function()
                            local currentTeam = LocalPlayer.Team
                            if currentTeam == Teams.Inmates then
                                repeat task.wait() TeamEvent:InvokeServer(Teams.Neutral) until LocalPlayer.Team == Teams.Neutral
                                repeat task.wait() TeamEvent:InvokeServer(Teams.Inmates) until LocalPlayer.Team == Teams.Inmates
                                fixcam()
                            elseif currentTeam == Teams.Guards then
                                repeat task.wait() TeamEvent:InvokeServer(Teams.Neutral) until LocalPlayer.Team == Teams.Neutral
                                repeat task.wait() TeamEvent:InvokeServer(Teams.Guards) until LocalPlayer.Team == Teams.Guards
                                fixcam()
                            elseif currentTeam == Teams.Criminals then
                                repeat task.wait() TeamEvent:InvokeServer(Teams.Neutral) until LocalPlayer.Team == Teams.Neutral
                                repeat task.wait() TeamEvent:InvokeServer(Teams.Inmates) until LocalPlayer.Team == Teams.Inmates
                                fixcam()
                            end
                            _G.CanQuickRespawn = true
                        end)
                    end
                    
                    if LocalPlayer.Team == Teams.Criminals then
                        tring = false
                        fugging = false
                    end
                end
            end)
        end
    end)
    
    Notify("AutoRespawn feature active", 3)
end

-- ============================================================================
-- ANTI-TASE IMPLEMENTATION
-- ============================================================================
-- Automatically removes tase effects and restores movement

local normalWS = 25
local normalJP = 50

-- Continuous check for tase effects
AntiFeatures_Connections.AntiTase = RunService.Heartbeat:Connect(function()
    if AntiFeatures_Enabled.AntiTase then
        pcall(function()
            local char = LocalPlayer.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    -- Restore walk speed if set to 0 (tased)
                    if hum.WalkSpeed == 0 then
                        hum.WalkSpeed = normalWS
                    else
                        normalWS = hum.WalkSpeed
                    end
                    
                    -- Restore jump power if set to 0 (tased)
                    if hum.JumpPower == 0 then
                        hum.JumpPower = normalJP
                    else
                        normalJP = hum.JumpPower
                    end
                end
            end
        end)
    end
end)

-- Animation-based anti-tase (stops the tase animation)
LocalPlayer.CharacterAdded:Connect(function(char)
    local humanoid = char:WaitForChild("Humanoid")
    local animator = humanoid:WaitForChild("Animator")
    
    animator.AnimationPlayed:Connect(function(animationTrack)
        -- Tase animation ID
        if AntiFeatures_Enabled.AntiTase and animationTrack.Animation.AnimationId == "rbxassetid://279227693" then
            pcall(function()
                animationTrack:Stop()
                animationTrack:Destroy()
                
                -- Restore character state
                LocalPlayer.Character.Humanoid.PlatformStand = false
                LocalPlayer.Character.Humanoid.Sit = false
                
                -- Restore movement
                task.wait()
                humanoid.WalkSpeed = normalWS
                humanoid.JumpPower = normalJP
                
                -- Re-enable controls
                if LocalPlayer.Character:FindFirstChild("ClientInputHandler") then
                    LocalPlayer.Character.ClientInputHandler.Disabled = false
                end
                
                -- Show backpack UI
                local nbgui = LocalPlayer.PlayerGui:FindFirstChild("Home")
                if nbgui and nbgui:FindFirstChild("hud") and nbgui.hud:FindFirstChild("BackpackUI") then
                    nbgui.hud.BackpackUI.Visible = true
                end
            end)
        end
    end)
end)

-- ============================================================================
-- CLEANUP FUNCTION (Optional - for disabling features)
-- ============================================================================
local function DisableAntiFeatures()
    for name, connection in pairs(AntiFeatures_Connections) do
        if connection then
            connection:Disconnect()
        end
    end
end


-- PL Features State Variables
local PLFeatures_States = {
    IsBringing = false,
}

local PLFeatures_Loops = {
    Voided = {},
    Trapped = {},
    CarFling = {},
}

local PLFeatures_SavedPositions = {}

local PLFeatures_Teleports = {
    trapbuilding = CFrame.new(-306.715485, 84.2401199, 1984.13367, -0.802221119, 5.70582088e-08, -0.597027004, 4.81801123e-08, 1, 3.08312771e-08, 0.597027004, -4.0313255e-09, -0.802221119),
}

-- ============================================================================
-- PL Features Helper Functions
-- ============================================================================

local function PL_LocTP(cframe)
    pcall(function()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            LocalPlayer.Character.HumanoidRootPart.CFrame = cframe
        end
    end)
end

local function PL_LAction(action, arg)
    pcall(function()
        if not LocalPlayer.Character then return end
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        if action == "sit" then
            humanoid.Sit = true
        elseif action == "unsit" then
            if arg then
                for i = 1, 8 do
                    RunService.Heartbeat:Wait()
                    humanoid.Sit = false
                    RunService.RenderStepped:Wait()
                    humanoid.Sit = false
                    RunService.Stepped:Wait()
                    humanoid.Sit = false
                end
            end
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
        end
    end)
end

local function PL_CPing()
    local ping = LocalPlayer:GetNetworkPing()
    return ping and ping or 0.05
end

local function PL_Notif(title, text)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 3,
    })
end

-- ============================================================================
-- Bring Car Function
-- ============================================================================
local function PL_BringCar(targetPlayer, useUsedCar)
    local success, err = pcall(function()
        local Car = nil
        local CarButton = workspace.Prison_ITEMS.buttons["Car Spawner"]["Car Spawner"]
        local ButtonPivot = CarButton:GetPivot()
        
        if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then
            PL_Notif("Error", "Character not ready")
            return
        end
        
        local LastPos = LocalPlayer.Character.HumanoidRootPart.CFrame
        PLFeatures_States.IsBringing = true
        
        if useUsedCar then
            for _, v in pairs(workspace.CarContainer:GetChildren()) do
                if v:IsA("Model") and v:FindFirstChild("Body") and v.Body:FindFirstChild("VehicleSeat") and not v.Body.VehicleSeat.Occupant then
                    for __, vv in pairs(v.Body:GetChildren()) do
                        if vv:IsA("Seat") and not vv.Occupant then
                            Car = v
                            break
                        end
                    end
                    if Car then break end
                end
            end
            if not Car then
                PLFeatures_States.IsBringing = false
                PL_Notif("Cancelled", "No used cars found")
                return
            end
        else
            task.spawn(function()
                Car = workspace.CarContainer.ChildAdded:Wait()
            end)
            repeat
                task.wait()
                task.spawn(function()
                    PL_LAction("unsit")
                    PL_LocTP(ButtonPivot)
                    workspace.Remote.ItemHandler:InvokeServer(CarButton)
                end)
            until Car
        end
        
        repeat task.wait() until Car:FindFirstChild("RWD") and Car:FindFirstChild("Body") and Car.Body:FindFirstChild("VehicleSeat")
        
        local Stopped, timeout = false, tick()
        while not Stopped do
            task.wait()
            pcall(function()
                PL_LocTP(CFrame.new(Car.Body.VehicleSeat.Position))
                Car.Body.VehicleSeat:Sit(LocalPlayer.Character:FindFirstChild("Humanoid"))
                Stopped = LocalPlayer.Character:FindFirstChild("Humanoid").Sit or tick() - timeout > 6
            end)
        end
        
        Car.PrimaryPart = Car:WaitForChild("RWD")
        
        if targetPlayer then
            local destiny = targetPlayer == LocalPlayer and LastPos or targetPlayer.Character:FindFirstChild("Head").CFrame
            Car:SetPrimaryPartCFrame(destiny)
            wait(0.2)
            PL_LAction("unsit", true)
            PL_LocTP(LastPos)
        else
            Car:SetPrimaryPartCFrame(LastPos)
        end
        
        PLFeatures_States.IsBringing = false
        PL_Notif("Success", "Car brought")
    end)
    
    if not success then
        PLFeatures_States.IsBringing = false
        warn("[PL_BringCar Error]", err)
    end
end

-- ============================================================================
-- Bring Player Function
-- ============================================================================
local function PL_BringPL(BringFrom, Destination, isCFrame, doNotUseCar)
    local success, err = pcall(function()
        -- Validate target
        if not BringFrom or not BringFrom.Character then
            PL_Notif("Error", "Invalid player")
            return
        end
        
        if BringFrom.TeamColor == BrickColor.new("Medium stone grey") then
            PL_Notif("Error", "Cannot bring neutral team")
            return
        end
        
        local targetHumanoid = BringFrom.Character:FindFirstChildOfClass("Humanoid")
        if not targetHumanoid or targetHumanoid.Health == 0 then
            PL_Notif("Error", "Player is dead")
            return
        end
        
        -- Validate local character
        if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then
            PL_Notif("Error", "Your character not ready")
            return
        end
        
        if LocalPlayer.Character:FindFirstChild("Humanoid").Sit then
            PL_LAction("unsit", true)
        end
        
        local LastPos = LocalPlayer.Character.HumanoidRootPart.CFrame
        
        -- If bringing self
        if BringFrom == LocalPlayer then
            if isCFrame then
                PL_LocTP(Destination)
            else
                PL_LocTP(Destination.Character:FindFirstChild("HumanoidRootPart").CFrame)
            end
            return
        end
        
        -- Get car
        local Car = nil
        local CarButton = workspace.Prison_ITEMS.buttons["Car Spawner"]["Car Spawner"]
        local ButtonPivot = CarButton:GetPivot()
        
        repeat
            task.wait()
            for _, v in pairs(workspace.CarContainer:GetChildren()) do
                if v:IsA("Model") and v:FindFirstChild("Body") and v.Body:FindFirstChild("VehicleSeat") and 
                   v.Name ~= "DONOTUSECAR" and not v.Body.VehicleSeat.Occupant then
                    for __, vv in pairs(v.Body:GetChildren()) do
                        if vv:IsA("Seat") and not vv.Occupant then
                            Car = v
                            break
                        end
                    end
                    if Car then break end
                end
            end
            
            if not Car then
                coroutine.wrap(function()
                    PL_LocTP(ButtonPivot)
                    workspace.Remote.ItemHandler:InvokeServer(CarButton)
                end)()
            end
        until Car
        
        if doNotUseCar then
            Car.Name = "DONOTUSECAR"
        end
        
        -- Wait for car to be ready
        repeat task.wait() until Car:FindFirstChild("RWD") and Car:FindFirstChild("Body") and Car.Body:FindFirstChild("VehicleSeat")
        
        PLFeatures_States.IsBringing = true
        
        -- Sit in car
        local seattimeout = tick() + 8
        local LHuman = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        local LRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        repeat
            task.wait()
            LHuman = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            LRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if LHuman and LRoot then
                LRoot.CFrame = CFrame.new(Car.Body.VehicleSeat.Position)
                Car.Body.VehicleSeat:Sit(LHuman)
            end
        until (LHuman and LHuman.Sit) or tick() - seattimeout >= 0
        
        if not LHuman or not LHuman.Sit then
            PL_LAction("unsit", true)
            PLFeatures_States.IsBringing = false
            PL_LocTP(LastPos)
            Car.Name = "DONOTUSECAR"
            PL_Notif("Error", "Failed to sit in car")
            return
        end
        
        -- Check target still valid
        if BringFrom.TeamColor == BrickColor.new("Medium stone grey") then
            PL_LAction("unsit", true)
            PLFeatures_States.IsBringing = false
            PL_LocTP(LastPos)
            PL_Notif("Error", "Player joined neutral team")
            return
        end
        
        -- Find target seat
        local TargetSeat = nil
        for _, v in pairs(Car.Body:GetChildren()) do
            if v:IsA("Seat") and not v.Occupant then
                TargetSeat = v
                break
            end
        end
        
        if not TargetSeat then
            PL_LocTP(LastPos)
            PLFeatures_States.IsBringing = false
            PL_Notif("Error", "Car seats full")
            return
        end
        
        -- Bring loop
        local VChar = BringFrom.Character
        local VHuman = VChar:FindFirstChildOfClass("Humanoid")
        local VRoot = VChar:FindFirstChild("HumanoidRootPart")
        
        if not (VChar and VHuman and VRoot) then
            PL_LAction("unsit", true)
            PL_LocTP(LastPos)
            PLFeatures_States.IsBringing = false
            PL_Notif("Error", "Target character invalid")
            return
        end
        
        local Timeout = tick() + 17
        local CarSpin, SpinRad = false, 0
        
        task.spawn(function()
            Car.PrimaryPart = TargetSeat
            Car:SetPrimaryPartCFrame(VRoot.CFrame * CFrame.new(0, -0.3, 0))
            task.wait(4)
            CarSpin = true
        end)
        
        repeat
            task.wait()
            local step1 = PL_CPing() / 2 / 2 / 2
            
            if TargetSeat.Occupant and not VHuman.Sit then
                for _, v in pairs(Car.Body:GetChildren()) do
                    if v:IsA("Seat") and not v.Occupant then
                        TargetSeat = v
                        break
                    end
                end
            end
            
            Car.PrimaryPart = TargetSeat
            local Movement = Vector3.new(VRoot.Velocity.X, 0, VRoot.Velocity.Z)
            local Predict = (VRoot.CFrame - (Vector3.new(0, 0, -0.1) * step1)) + (Movement * (step1 * 28))
            
            if Predict.Position.Y > 1 then
                if CarSpin then
                    SpinRad = SpinRad + 30
                    Car:SetPrimaryPartCFrame(Predict * CFrame.Angles(0, math.rad(SpinRad), 0))
                else
                    Car:SetPrimaryPartCFrame(Predict)
                end
            else
                Car:SetPrimaryPartCFrame(LastPos)
            end
            
            if BringFrom.TeamColor == BrickColor.new("Medium stone grey") then
                break
            end
        until not LocalPlayer.Character or not LHuman or not LHuman.Sit or 
              not BringFrom.Character or VChar ~= BringFrom.Character or 
              VHuman.Sit or VHuman.Health == 0 or tick() - Timeout >= 0
        
        if VHuman and not VHuman.Sit then
            PL_LAction("unsit", true)
            PL_LocTP(LastPos)
            PLFeatures_States.IsBringing = false
            PL_Notif("Error", "Failed to bring player")
            return
        end
        
        -- Position at destination
        if isCFrame then
            Car.PrimaryPart = Car:FindFirstChild("RWD")
            Car:SetPrimaryPartCFrame(Destination)
        else
            Car.PrimaryPart = Car:FindFirstChild("RWD")
            local Destiny = Destination ~= LocalPlayer and Destination.Character:FindFirstChild("HumanoidRootPart").CFrame or LastPos
            Car:SetPrimaryPartCFrame(Destiny)
            if Destination ~= LocalPlayer and doNotUseCar then
                wait(0.2)
                PL_LAction("unsit", true)
                PL_LocTP(LastPos)
            end
        end
        
        -- Dump car
        if not doNotUseCar then
            local Tinedout = tick() + 15
            repeat task.wait() until VHuman.Health == 0 or not VHuman.Sit or 
                                    tick() - Tinedout >= 0 or 
                                    not Players:FindFirstChild(BringFrom.Name)
            
            if not LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Sit then
                LastPos = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                repeat
                    task.wait()
                    Car.Body.VehicleSeat:Sit(LocalPlayer.Character:FindFirstChildOfClass("Humanoid"))
                until LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Sit
            end
            
            Car.PrimaryPart = Car:FindFirstChild("RWD")
            Car:SetPrimaryPartCFrame(CFrame.new(0, 9, 0))
            wait(0.2)
            PL_LAction("unsit", true)
            PL_LocTP(LastPos)
        end
        
        PLFeatures_States.IsBringing = false
        PL_Notif("Success", "Brought " .. BringFrom.Name)
    end)
    
    if not success then
        PLFeatures_States.IsBringing = false
        warn("[PL_BringPL Error]", err)
        PL_Notif("Error", "Bring failed: " .. tostring(err))
    end
end

-- ============================================================================
-- Car Fling Function
-- ============================================================================
local function PL_CarFlingPL(targetPlayer)
    local success, err = pcall(function()
        if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then
            PL_Notif("Error", "Character not ready")
            return
        end
        
        local tempos = LocalPlayer.Character.HumanoidRootPart.CFrame
        PL_BringPL(targetPlayer, targetPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame, true, true)
        
        task.wait(0.5)
        
        local char = LocalPlayer.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then
            return
        end
        
        local bv = Instance.new("BodyVelocity")
        bv.Parent = char.HumanoidRootPart
        
        local bg = Instance.new("BodyGyro")
        bg.Parent = char.HumanoidRootPart
        
        for i = 1, 10 do
            bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
            bg.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
            bg.CFrame = bg.CFrame * CFrame.new(math.random(69, 699999), math.random(69, 6966868), math.random(6996, 66886))
            bv.Velocity = Vector3.new(math.random(69, 699), 1e6, math.random(69, 699))
            RunService.Stepped:Wait()
        end
        
        RunService.Stepped:Wait()
        RunService.Heartbeat:Wait()
        
        bv:Destroy()
        bg:Destroy()
        
        -- Respawn
        if LocalPlayer.TeamColor == BrickColor.new("Bright blue") then
            workspace.Remote.TeamEvent:FireServer("Bright blue")
        else
            workspace.Remote.TeamEvent:FireServer("Bright orange")
        end
        
        LocalPlayer.CharacterAdded:Wait()
        wait(0.5)
        PL_LocTP(tempos)
        
        PL_Notif("Success", "Flung " .. targetPlayer.Name)
    end)
    
    if not success then
        warn("[PL_CarFlingPL Error]", err)
        PL_Notif("Error", "Fling failed: " .. tostring(err))
    end
end

-- ============================================================================
-- Loop System
-- ============================================================================
task.spawn(function()
    while task.wait(0.5) do
        pcall(function()
            -- Loop Trapped
            if next(PLFeatures_Loops.Trapped) then
                for userId, player in next, PLFeatures_Loops.Trapped do
                    if player and player.Character and player.Character:FindFirstChild("Humanoid") and 
                       player.Character:FindFirstChild("HumanoidRootPart") then
                        if not (player.Character.Humanoid.Health == 0 or 
                                player.Character.Humanoid.Sit or 
                                player.TeamColor.Name == "Medium stone grey") then
                            if (player.Character.HumanoidRootPart.Position - PLFeatures_Teleports.trapbuilding.Position).Magnitude > 90 then
                                PLFeatures_SavedPositions.TrapPlayerPos = PLFeatures_SavedPositions.TrapPlayerPos or 
                                    LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                                PL_BringPL(player, PLFeatures_Teleports.trapbuilding, true)
                            end
                        end
                    end
                end
                
                if PLFeatures_SavedPositions.TrapPlayerPos then
                    wait(0.2)
                    PL_LAction("unsit", true)
                    PL_LocTP(PLFeatures_SavedPositions.TrapPlayerPos)
                    PLFeatures_SavedPositions.TrapPlayerPos = nil
                end
            end
            
            -- Loop Voided
            if next(PLFeatures_Loops.Voided) then
                for userId, player in next, PLFeatures_Loops.Voided do
                    if player and player.Character and player.Character:FindFirstChild("Humanoid") and
                       player.Character:FindFirstChild("Head") then
                        if not (player.Character.Humanoid.Health == 0 or 
                                player.Character.Humanoid.Sit or 
                                player.TeamColor.Name == "Medium stone grey") then
                            if player.Character.Head.Position.Y < 699 then
                                local tempos = LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame
                                PL_BringPL(player, CFrame.new(0, 9e9, 0), true, true)
                                wait(0.5)
                                
                                if LocalPlayer.TeamColor == BrickColor.new("Bright blue") then
                                    workspace.Remote.TeamEvent:FireServer("Bright blue")
                                else
                                    workspace.Remote.TeamEvent:FireServer("Bright orange")
                                end
                                
                                LocalPlayer.CharacterAdded:Wait()
                                wait(0.5)
                                PL_LocTP(tempos)
                            end
                        end
                    end
                end
            end
            
            -- Loop CarFling
            if next(PLFeatures_Loops.CarFling) then
                for userId, player in next, PLFeatures_Loops.CarFling do
                    if player and player.Character and player.Character:FindFirstChild("Humanoid") and
                       player.Character:FindFirstChild("Head") then
                        if not (player.TeamColor == BrickColor.new("Medium stone grey") or 
                                player.Character.Humanoid.Health == 0 or 
                                player.Character.Humanoid.Sit) then
                            if player.Character.Head.Position.Y < 999 then
                                PL_CarFlingPL(player)
                                wait(2) -- Cooldown between flings
                            end
                        end
                    end
                end
            end
        end)
    end
end)



if Env.cfg.autoarrest == nil then
    Env.cfg.autoarrest = false
end
if Env.cfg.punchaura == nil then
    Env.cfg.punchaura = false
end
if Env.cfg.ws_enabled == nil then
    Env.cfg.ws_enabled = false
end
if Env.cfg.walkspeed == nil then
    Env.cfg.walkspeed = 16
end
if Env.cfg.jp_enabled == nil then
    Env.cfg.jp_enabled = false
end
if Env.cfg.jumppower == nil then
    Env.cfg.jumppower = 50
end
if Env.cfg.noclip == nil then
    Env.cfg.noclip = false
end
if Env.cfg.shootarrested == nil then
    Env.cfg.shootarrested = false
end
if Env.cfg.autograb == nil then
    Env.cfg.autograb = false
end

local noclipConnection = nil

local function updateNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()

        noclipConnection = nil
    end
    if Env.cfg.noclip then
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character

            if char then
                for _, part in pairs(char:GetDescendants())do
                    if part:IsA('BasePart') then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end

task.spawn(function()
    pcall(function()
        local hook = newcclosure(function()
            return
        end)

        for _, obj in getgc(false)do
            if typeof(obj) == 'function' then
                local source = debug.info(obj, 's')

                if source and source:find('CharacterCollision') then
                    hookfunction(obj, hook)
                end
            end
        end
    end)
end)
task.spawn(function()
    while true do
        if Env.cfg.shootarrested then
            local rs = ReplicatedStorage
            local re = rs:FindFirstChild('Remotes') and rs.Remotes:FindFirstChild('ClientArrested')

            if re then
                for _, cn in pairs(getconnections(re.OnClientEvent))do
                    cn:Disable()
                end
            end
        end

        task.wait(1)
    end
end)

local grab_dist_sq = 144
local last_grab = 0
local giver_remote = ReplicatedStorage:WaitForChild('Remotes'):FindFirstChild('GiverPressed')
local grab_cache = {}
local cache_update_interval = 2
local last_cache_update = 0

local function updateGrabCache()
    grab_cache = {}

    for _, obj in pairs(Workspace:GetDescendants())do
        if obj:IsA('Model') and (obj.Name:lower():find('keycard') or obj.Name == 'M9') then
            local part = obj.PrimaryPart or obj:FindFirstChildWhichIsA('BasePart', true)

            if part then
                local isOwned = false
                local anc = obj.Parent

                while anc and anc ~= Workspace do
                    if anc:FindFirstChild('Humanoid') or anc.Name == 'Backpack' then
                        isOwned = true

                        break
                    end

                    anc = anc.Parent
                end

                if not isOwned then
                    table.insert(grab_cache, {
                        model = obj,
                        part = part,
                    })
                end
            end
        end
    end
end

RunService.Heartbeat:Connect(function()
    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild('HumanoidRootPart')
    local myHum = myChar and myChar:FindFirstChild('Humanoid')

    if myHum and myHrp then
        if Env.cfg.ws_enabled then
            myHum.WalkSpeed = Env.cfg.walkspeed
        end
        if Env.cfg.jp_enabled then
            myHum.JumpPower = Env.cfg.jumppower
        end
    end
    if Env.cfg.autograb and myHrp and giver_remote then
        local now = tick()

        if now - last_cache_update > cache_update_interval then
            updateGrabCache()

            last_cache_update = now
        end
        if now - last_grab > 0.5 then
            for _, cached in ipairs(grab_cache)do
                if cached.model and cached.part and cached.part.Parent then
                    local distSq = (cached.part.Position - myHrp.Position).Magnitude ^ 2

                    if distSq <= grab_dist_sq then
                        last_grab = now

                        giver_remote:FireServer(cached.model)

                        break
                    end
                end
            end
        end
    end
    -- Auto Arrest Logic
    if Env.cfg.autoarrest and myHrp then
        local arrestRemote = ReplicatedStorage:FindFirstChild('Remotes') and ReplicatedStorage.Remotes:FindFirstChild('ArrestPlayer')
        local ARREST_RANGE = 10
        
        if arrestRemote then
            for _, target in ipairs(Players:GetPlayers())do
                if target == LocalPlayer then continue end
                
                local char = target.Character
                if not char then continue end
                
                local hrp = char:FindFirstChild('HumanoidRootPart')
                local hum = char:FindFirstChild('Humanoid')
                
                -- Checks: Part existence, Health, and Distance
                if hrp and hum and hum.Health > 0 then
                    if (myHrp.Position - hrp.Position).Magnitude <= ARREST_RANGE then
                        task.spawn(function()
                            pcall(function()
                                arrestRemote:InvokeServer(target)
                            end)
                        end)
                    end
                end
            end
        end
    end
    
    -- Punch Aura Logic
    if Env.cfg.punchaura and myHrp then
        for _, target in ipairs(Players:GetPlayers())do
            if target ~= LocalPlayer and target.Character and target.Character:FindFirstChild('HumanoidRootPart') then
                local targetHrp = target.Character.HumanoidRootPart
                local dist = (targetHrp.Position - myHrp.Position).Magnitude

                if dist <= 25 then
                    if target.Team ~= LocalPlayer.Team then
                        if not target.Character:FindFirstChild('ForceField') then
                            ReplicatedStorage.meleeEvent:FireServer(target)
                        end
                    end
                end
            end
        end
    end
end)

local configFolder = 'CasualComasConfigs'

local function serializeColor3(color)
    return {
        R = color.R,
        G = color.G,
        B = color.B,
    }
end
local function deserializeColor3(tbl)
    if tbl and tbl.R and tbl.G and tbl.B then
        return Color3.new(tbl.R, tbl.G, tbl.B)
    end

    return Color3.new(1, 1, 1)
end
local function serializeConfig()
    local data = {}

    for key, value in pairs(Env.cfg)do
        if typeof(value) == 'Color3' then
            data[key] = {
                type = 'Color3',
                value = serializeColor3(value),
            }
        elseif typeof(value) == 'EnumItem' then
            data[key] = {
                type = 'EnumItem',
                value = tostring(value),
            }
        elseif typeof(value) == 'table' then
            data[key] = {
                type = 'table',
                value = value,
            }
        else
            data[key] = {
                type = typeof(value),
                value = value,
            }
        end
    end

    return HttpService:JSONEncode(data)
end
local function deserializeConfig(jsonString)
    local success, data = pcall(function()
        return HttpService:JSONDecode(jsonString)
    end)

    if not success then
        return nil
    end

    local result = {}

    for key, entry in pairs(data)do
        if entry.type == 'Color3' then
            result[key] = deserializeColor3(entry.value)
        elseif entry.type == 'EnumItem' then
            local enumPath = entry.value:match('Enum%.(.+)')

            if enumPath then
                local parts = enumPath:split('.')

                if #parts == 2 then
                    local enumType = Enum[parts[1] ]

                    if enumType then
                        result[key] = enumType[parts[2] ]
                    end
                end
            end
        elseif entry.type == 'table' then
            result[key] = entry.value
        else
            result[key] = entry.value
        end
    end

    return result
end
local function saveConfig(name)
    if not isfolder then
        return false
    end
    if not isfolder(configFolder) then
        makefolder(configFolder)
    end

    local path = configFolder .. '/' .. name .. '.json'

    writefile(path, serializeConfig())

    return true
end
local function loadConfig(name)
    if not isfolder or not isfile then
        return false
    end

    local path = configFolder .. '/' .. name .. '.json'

    if not isfile(path) then
        return false
    end

    local data = readfile(path)
    local loaded = deserializeConfig(data)

    if not loaded then
        return false
    end

    for key, value in pairs(loaded)do
        if Env.cfg[key] ~= nil then
            Env.cfg[key] = value
        end
    end

    if Env.updateEsp then
        Env.updateEsp()
    end
    if Env.updateC4Esp then
        Env.updateC4Esp()
    end

    updateNoclip()

    return true
end

local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = 'Casual Comas',
    Icon = 79844328689721,
    LoadingTitle = 'Casual Comas Hub',
    LoadingSubtitle = 'v' .. Env.Version .. ' - Nebula Storm',
    Theme = NebulaStorm,
    ConfigurationSaving = {Enabled = false},
    KeySystem = false,
})
local CombatTab = Window:CreateTab('Combat', 'crosshair')
local VisualsTab = Window:CreateTab('Visuals', 'eye')
local MovementTab = Window:CreateTab('Movement', 'wind')
local VehicleTab = Window:CreateTab('Vehicle', 'car')
local UtilityTab = Window:CreateTab('Utility', 'box')
local ConfigTab = Window:CreateTab('Config', 'settings')

CombatTab:CreateSection('Silent Aim')
CombatTab:CreateToggle({
    Name = 'Enable Silent Aim',
    CurrentValue = Env.cfg.enabled,
    Callback = function(v)
        Env.cfg.enabled = v
    end,
})
CombatTab:CreateSlider({
    Name = 'FOV Radius',
    Range = {10, 500},
    Increment = 1,
    Suffix = 'px',
    CurrentValue = Env.cfg.fov,
    Callback = function(v)
        Env.cfg.fov = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Show FOV Circle',
    CurrentValue = Env.cfg.showfov,
    Callback = function(v)
        Env.cfg.showfov = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Hit Chance',
    Range = {0, 100},
    Increment = 1,
    Suffix = '%',
    CurrentValue = Env.cfg.hitchance,
    Callback = function(v)
        Env.cfg.hitchance = v
    end,
})
CombatTab:CreateDropdown({
    Name = 'Target Part',
    Options = Env.cfg.partslist,
    CurrentOption = {
        Env.cfg.aimpart,
    },
    MultipleOptions = false,
    Callback = function(o)
        Env.cfg.aimpart = o[1]
    end,
})
CombatTab:CreateToggle({
    Name = 'Random Parts',
    CurrentValue = Env.cfg.randomparts,
    Callback = function(v)
        Env.cfg.randomparts = v
    end,
})
CombatTab:CreateSection('Targeting')
CombatTab:CreateToggle({
    Name = 'Team Check',
    CurrentValue = Env.cfg.teamcheck,
    Callback = function(v)
        Env.cfg.teamcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Wall Check',
    CurrentValue = Env.cfg.wallcheck,
    Callback = function(v)
        Env.cfg.wallcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Death Check',
    CurrentValue = Env.cfg.deathcheck,
    Callback = function(v)
        Env.cfg.deathcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'ForceField Check',
    CurrentValue = Env.cfg.ffcheck,
    Callback = function(v)
        Env.cfg.ffcheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Vehicle Check',
    CurrentValue = Env.cfg.vehiclecheck,
    Callback = function(v)
        Env.cfg.vehiclecheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Hostile Check (Guards)',
    CurrentValue = Env.cfg.hostilecheck,
    Callback = function(v)
        Env.cfg.hostilecheck = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Trespass Check (Guards)',
    CurrentValue = Env.cfg.trespasscheck,
    Callback = function(v)
        Env.cfg.trespasscheck = v
    end,
})
CombatTab:CreateSection('Automation')
CombatTab:CreateToggle({
    Name = 'Auto Shoot',
    CurrentValue = Env.cfg.autoshoot,
    Callback = function(v)
        Env.cfg.autoshoot = v
    end,
})

CombatTab:CreateSection('Ammo & Reload')

CombatTab:CreateToggle({
    Name = 'Instant Reload',
    CurrentValue = AutoReload_Settings.instant_reload,
    Callback = function(v)
        AutoReload_Settings.instant_reload = v
        
        if v then
            StartInstantReload()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Instant Reload",
                Text = "Enabled - Reload time: 0.01s",
                Duration = 3,
            })
        else
            if AutoReload_Connections.InstantReload then
                pcall(function()
                    if typeof(AutoReload_Connections.InstantReload) == "RBXScriptConnection" then
                        AutoReload_Connections.InstantReload:Disconnect()
                    end
                end)
                AutoReload_Connections.InstantReload = nil
            end
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Instant Reload",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})

CombatTab:CreateSlider({
    Name = 'Reload Speed',
    Range = {0.01, 2},
    Increment = 0.01,
    Suffix = 's',
    CurrentValue = AutoReload_Settings.reload_time,
    Callback = function(v)
        AutoReload_Settings.reload_time = v
    end,
})

CombatTab:CreateToggle({
    Name = 'Auto Reload',
    CurrentValue = AutoReload_Settings.enabled,
    Callback = function(v)
        AutoReload_Settings.enabled = v
        
        if v then
            SetupAutoReload()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Reload",
                Text = "Enabled - Auto reload at " .. AutoReload_Settings.auto_reload_threshold .. " ammo",
                Duration = 3,
            })
        else
            if AutoReload_Connections.AutoReload then
                pcall(function()
                    if typeof(AutoReload_Connections.AutoReload) == "RBXScriptConnection" then
                        AutoReload_Connections.AutoReload:Disconnect()
                    end
                end)
                AutoReload_Connections.AutoReload = nil
            end
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Reload",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})

CombatTab:CreateSlider({
    Name = 'Auto Reload Threshold',
    Range = {0, 30},
    Increment = 1,
    Suffix = ' ammo',
    CurrentValue = AutoReload_Settings.auto_reload_threshold,
    Callback = function(v)
        AutoReload_Settings.auto_reload_threshold = v
    end,
})

CombatTab:CreateToggle({
    Name = 'Infinite Ammo',
    CurrentValue = InfiniteAmmo_Enabled,
    Callback = function(v)
        InfiniteAmmo_Enabled = v
        
        if v then
            SetupInfiniteAmmo()
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Infinite Ammo",
                Text = "Enabled - Never run out of ammo",
                Duration = 3,
            })
        else
            if AutoReload_Connections.InfiniteAmmo then
                pcall(function()
                    if typeof(AutoReload_Connections.InfiniteAmmo) == "RBXScriptConnection" then
                        AutoReload_Connections.InfiniteAmmo:Disconnect()
                    end
                end)
                AutoReload_Connections.InfiniteAmmo = nil
            end
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Infinite Ammo",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})

-- ============================================================================
-- WEAPON MACRO SYSTEM
-- ============================================================================

CombatTab:CreateSection('Weapon Macro')

-- Macro state
local macroActive = false
local selectedWeapons = {}
local maxSelect = 3
local switchDelay = 0.09
local macroThread = nil
local lastEquippedTool = nil

local weaponNames = {"FAL", "M9", "Remington 870", "M4A1", "AK-47", "MP5"}

local function findToolByName(name)
    local player = LocalPlayer
    local char = player.Character
    if char then
        local t = char:FindFirstChild(name)
        if t and t:IsA("Tool") then return t, "Character" end
    end
    local back = player:FindFirstChild("Backpack")
    if back then
        local t = back:FindFirstChild(name)
        if t and t:IsA("Tool") then return t, "Backpack" end
    end
    return nil, nil
end

local function safeEquipByName(name)
    local player = LocalPlayer
    local char = player.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    pcall(function() humanoid:UnequipTools() end)
    
    local tool, source = findToolByName(name)
    if not tool then return false end
    
    local ok, _ = pcall(function()
        humanoid:EquipTool(tool)
        lastEquippedTool = tool
    end)
    return ok
end

local function countSelected()
    local c = 0
    for _ in pairs(selectedWeapons) do c = c + 1 end
    return c
end

local function startMacro()
    if macroThread then return end
    macroActive = true
    
    macroThread = task.spawn(function()
        while macroActive do
            local names = {}
            for name in pairs(selectedWeapons) do table.insert(names, name) end
            table.sort(names)
            
            if #names == 0 then
                task.wait(0.15)
            else
                for _, name in ipairs(names) do
                    if not macroActive then break end
                    pcall(function() safeEquipByName(name) end)
                    task.wait(switchDelay)
                end
            end
            task.wait(0.02)
        end
        macroThread = nil
    end)
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Weapon Macro",
        Text = "Started - Switching " .. countSelected() .. " weapons",
        Duration = 2,
    })
end

local function stopMacro()
    macroActive = false
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Weapon Macro",
        Text = "Stopped",
        Duration = 2,
    })
end

-- Weapon selection dropdowns (allow selecting up to 3 weapons)
local selectedSlot1 = nil
local selectedSlot2 = nil
local selectedSlot3 = nil

CombatTab:CreateDropdown({
    Name = 'Weapon Slot 1',
    Options = weaponNames,
    Callback = function(Option)
        local weaponName = Option[1]
        if selectedSlot1 then
            selectedWeapons[selectedSlot1] = nil
        end
        selectedSlot1 = weaponName
        selectedWeapons[weaponName] = true
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Weapon Macro",
            Text = "Slot 1: " .. weaponName .. " | Total: " .. countSelected(),
            Duration = 2,
        })
    end,
})

CombatTab:CreateDropdown({
    Name = 'Weapon Slot 2',
    Options = weaponNames,
    Callback = function(Option)
        local weaponName = Option[1]
        if selectedSlot2 then
            selectedWeapons[selectedSlot2] = nil
        end
        selectedSlot2 = weaponName
        selectedWeapons[weaponName] = true
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Weapon Macro",
            Text = "Slot 2: " .. weaponName .. " | Total: " .. countSelected(),
            Duration = 2,
        })
    end,
})

CombatTab:CreateDropdown({
    Name = 'Weapon Slot 3',
    Options = weaponNames,
    Callback = function(Option)
        local weaponName = Option[1]
        if selectedSlot3 then
            selectedWeapons[selectedSlot3] = nil
        end
        selectedSlot3 = weaponName
        selectedWeapons[weaponName] = true
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Weapon Macro",
            Text = "Slot 3: " .. weaponName .. " | Total: " .. countSelected(),
            Duration = 2,
        })
    end,
})

CombatTab:CreateToggle({
    Name = 'Enable Macro',
    CurrentValue = false,
    Callback = function(v)
        if v then
            if countSelected() == 0 then
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "Weapon Macro",
                    Text = "Please select at least one weapon!",
                    Duration = 3,
                })
                return
            end
            startMacro()
        else
            stopMacro()
        end
    end,
})

CombatTab:CreateSlider({
    Name = 'Switch Delay',
    Range = {0.01, 0.5},
    Increment = 0.01,
    Suffix = 's',
    CurrentValue = switchDelay,
    Callback = function(v)
        switchDelay = v
    end,
})

CombatTab:CreateButton({
    Name = 'Clear All Weapons',
    Callback = function()
        selectedWeapons = {}
        selectedSlot1 = nil
        selectedSlot2 = nil
        selectedSlot3 = nil
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Weapon Macro",
            Text = "All weapons cleared",
            Duration = 2,
        })
    end,
})


CombatTab:CreateSection('Modification(s)')


CombatTab:CreateSlider({
    Name = 'Shot Delay',
    Range = {0.05, 0.5},
    Increment = 0.01,
    Suffix = 's',
    CurrentValue = Env.cfg.autoshootdelay,
    Callback = function(v)
        Env.cfg.autoshootdelay = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Start Delay',
    Range = {0, 1},
    Increment = 0.05,
    Suffix = 's',
    CurrentValue = Env.cfg.autoshootstartdelay,
    Callback = function(v)
        Env.cfg.autoshootstartdelay = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Auto Arrest',
    CurrentValue = Env.cfg.autoarrest,
    Callback = function(v)
        Env.cfg.autoarrest = v
    end,
})
CombatTab:CreateToggle({
    Name = 'Punch Aura',
    CurrentValue = Env.cfg.punchaura,
    Callback = function(v)
        Env.cfg.punchaura = v
    end,
})
CombatTab:CreateSection('Shield Breaker')
CombatTab:CreateToggle({
    Name = 'Enable Shield Breaker',
    CurrentValue = Env.cfg.shieldbreaker,
    Callback = function(v)
        Env.cfg.shieldbreaker = v
    end,
})
CombatTab:CreateSlider({
    Name = 'Head Shot Chance',
    Range = {0, 100},
    Increment = 1,
    Suffix = '%',
    CurrentValue = Env.cfg.shieldheadchance,
    Callback = function(v)
        Env.cfg.shieldheadchance = v
    end,
})






CombatTab:CreateSection('Gun Obtainer')

-- Gun Obtainer Variables
local gunAliases = {
    ["ak-47"] = "AK-47",
    ["mp5"] = "MP5",
    ["ak"] = "AK-47",
    ["ak47"] = "AK-47",
    ["remington"] = "Remington 870",
    ["rem"] = "Remington 870",
    ["shotgun"] = "Remington 870",
    ["m4"] = "M4A1",
    ["m4a1"] = "M4A1",
    ["fal"] = "FAL"
}

-- Check for game passes
local function checkRIOT()
    if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LocalPlayer.UserId, 643697197) then
        return true
    end
    if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LocalPlayer.UserId, 96651) then
        return true
    end
    return false
end

local function checkMAFIA()
    if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LocalPlayer.UserId, 1443271) then
        return true
    end
    return false
end

local function checkSniper()
    if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(LocalPlayer.UserId, 699360089) then
        return true
    end
    return false
end

local riot_pass = checkRIOT()
local mafia_pass = checkMAFIA()
local sniper_pass = checkSniper()

-- Build gun list based on gamepasses
local allGuns = {"AK-47", "Remington 870", "MP5"}

if riot_pass then
    table.insert(allGuns, "M4A1")
end

if mafia_pass then
    table.insert(allGuns, "FAL")
end

if sniper_pass then
    table.insert(allGuns, "M700")
end

local AlreadyFound = {}

local function FindGunSpawner(GunName)
    if AlreadyFound[GunName] then
        return AlreadyFound[GunName], true
    end

    for _, v in ipairs(Workspace:GetDescendants()) do
        if v.Name == "TouchGiver" then
            local ActualGiver = v:FindFirstChild("TouchGiver") or v

            if v:GetAttribute("ToolName") == GunName then
                AlreadyFound[GunName] = ActualGiver
                return ActualGiver, false
            end

            if v.Parent and v.Parent:GetAttribute("ToolName") == GunName then
                AlreadyFound[GunName] = ActualGiver
                return ActualGiver, false
            end
        end
    end

    warn("Can't find", GunName)
    return nil, nil
end

local function GetTool(ToolName)
    return LocalPlayer:FindFirstChild("Backpack") and LocalPlayer.Backpack:FindFirstChild(ToolName) or LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(ToolName)
end

local function GetGun(GunName)
    local Giver, Found = FindGunSpawner(GunName)
    if not Giver then return end
    
    if not Found then
        local CloneGiver = Giver:Clone()
        CloneGiver.Parent = Giver.Parent
        Giver.Parent = Workspace.Folder
        Giver.CanCollide = false
        Giver.Transparency = 1
    end
    
    local hrp = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    hrp.CFrame = Giver.CFrame * CFrame.new(math.random(-2, 2), 0, 0)
    
    repeat task.wait()
    until GetTool(GunName)
end

local function hasGun(name)
    local backpack = LocalPlayer:WaitForChild("Backpack")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return backpack:FindFirstChild(name) or char:FindFirstChild(name)
end

local function GrabGuns(gunsToGrab)
    local obtained = {}
    for _, gun in ipairs(gunsToGrab) do
        if not hasGun(gun) then
            if GetGun(gun) then
                table.insert(obtained, gun)
            end
            task.wait(0.35)
        end
    end

    if #obtained == 0 then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Gun Obtainer",
            Text = "All guns already in inventory!",
            Duration = 3,
        })
    elseif #obtained == 1 then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Gun Obtainer",
            Text = "Obtained " .. obtained[1],
            Duration = 3,
        })
    else
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Gun Obtainer",
            Text = "Obtained all guns!",
            Duration = 3,
        })
    end
end

-- Gun Obtainer UI
local selectedGun = nil

CombatTab:CreateDropdown({
    Name = 'Get Specific Gun',
    Options = allGuns,
    Callback = function(Option)
        selectedGun = Option[1]
    end,
})

CombatTab:CreateButton({
    Name = 'Get Selected Gun',
    Callback = function()
        if not selectedGun then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Gun Obtainer",
                Text = "Please select a gun first!",
                Duration = 3,
            })
            return
        end
        
        local hrp = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        local oldCFrame = hrp.CFrame
        GetGun(selectedGun)
        hrp.CFrame = oldCFrame
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Gun Obtainer",
            Text = "Obtained " .. selectedGun,
            Duration = 3,
        })
    end,
})

CombatTab:CreateButton({
    Name = 'Get All Guns',
    Callback = function()
        local hrp = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
        local oldCFrame = hrp.CFrame
        
        for i, v in ipairs(allGuns) do
            if (v == "M4A1" and riot_pass == false) or (v == "FAL" and mafia_pass == false) or (v == "M700" and not sniper_pass) then
                -- Skip guns that require gamepasses we don't have
            else
                if not GetTool(v) then
                    GetGun(v)
                end
            end
        end
        
        hrp.CFrame = oldCFrame
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Gun Obtainer",
            Text = "Obtained all available guns!",
            Duration = 3,
        })
    end,
})



-- ============================================================================
-- GUN'S TRUE RANGE SYSTEM
-- ============================================================================

CombatTab:CreateSection("Gun's True Range")

-- Gun's True Range Variables
local GunTrueRange_Enabled = false
local GunTrueRange_Connections = {}

-- Gun animation script
local function startGunTrueRange()
    if GunTrueRange_Connections.RenderStepped then
        return -- Already running
    end
    
    local player = Players.LocalPlayer
    local DEPTH = -10
    local HEIGHT = 2
    local FLOAT_SPEED = 2
    local ROTATION_SPEED = 1.5
    local ORBIT_RADIUS = 3
    local activeConnections = {}
    
    local function animateTool(tool)
        if not tool:IsA("Tool") then return end
        local startTime = tick()
        
        -- Clean up existing connection for this tool if it exists
        if activeConnections[tool] then
            pcall(function()
                if typeof(activeConnections[tool]) == "RBXScriptConnection" then
                    activeConnections[tool]:Disconnect()
                end
            end)
            activeConnections[tool] = nil
        end
        
        activeConnections[tool] = RunService.RenderStepped:Connect(function()
            if not tool or not tool.Parent then
                -- Store connection reference before setting to nil
                local conn = activeConnections[tool]
                activeConnections[tool] = nil
                
                -- Safely disconnect
                if conn and typeof(conn) == "RBXScriptConnection" then
                    pcall(function()
                        conn:Disconnect()
                    end)
                end
                return
            end
            local t = tick() - startTime
            local yOffset = math.sin(t * FLOAT_SPEED) * HEIGHT
            local angle = t * ROTATION_SPEED
            tool.Grip =
                CFrame.new(
                    math.cos(angle) * ORBIT_RADIUS,
                    DEPTH + yOffset,
                    math.sin(angle) * ORBIT_RADIUS
                )
                * CFrame.Angles(0, angle, 0)
        end)
    end
    
    local function onCharacter(character)
        GunTrueRange_Connections.ChildAdded = character.ChildAdded:Connect(animateTool)
        for _, child in ipairs(character:GetChildren()) do
            animateTool(child)
        end
    end
    
    if player.Character then
        onCharacter(player.Character)
    end
    
    GunTrueRange_Connections.CharacterAdded = player.CharacterAdded:Connect(onCharacter)
    
    -- Store active tool connections for cleanup
    GunTrueRange_Connections.activeToolConnections = activeConnections
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Gun's True Range",
        Text = "Enabled - Weapons animated",
        Duration = 3,
    })
end

local function stopGunTrueRange()
    -- Disconnect all connections safely
    for name, connection in pairs(GunTrueRange_Connections) do
        if name ~= "activeToolConnections" then
            pcall(function()
                if connection and typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
            end)
        end
    end
    
    -- Disconnect active tool connections safely
    if GunTrueRange_Connections.activeToolConnections then
        for tool, connection in pairs(GunTrueRange_Connections.activeToolConnections) do
            pcall(function()
                if connection and typeof(connection) == "RBXScriptConnection" then
                    connection:Disconnect()
                end
            end)
        end
    end
    
    -- Clear connections table
    GunTrueRange_Connections = {}
    
    -- Reset all tools to default grip
    local player = Players.LocalPlayer
    if player and player.Character then
        for _, child in ipairs(player.Character:GetChildren()) do
            if child:IsA("Tool") then
                pcall(function()
                    child.Grip = CFrame.new(0, 0, 0)
                end)
            end
        end
    end
    
    local backpack = player and player:FindFirstChild("Backpack")
    if backpack then
        for _, child in ipairs(backpack:GetChildren()) do
            if child:IsA("Tool") then
                child.Grip = CFrame.new(0, 0, 0)
            end
        end
    end
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Gun's True Range",
        Text = "Disabled - Weapons reset",
        Duration = 3,
    })
end

CombatTab:CreateToggle({
    Name = "Gun's True Range",
    CurrentValue = GunTrueRange_Enabled,
    Callback = function(v)
        GunTrueRange_Enabled = v
        
        if v then
            startGunTrueRange()
        else
            stopGunTrueRange()
        end
    end,
})

-- ============================================================================
-- END GUN'S TRUE RANGE SYSTEM
-- ============================================================================

CombatTab:CreateSection('Anti Features')

CombatTab:CreateToggle({
    Name = 'Anti-Void',
    CurrentValue = AntiFeatures_Enabled.AntiVoid,
    Callback = function(v)
        AntiFeatures_Enabled.AntiVoid = v
        
        if v then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Anti-Void",
                Text = "Enabled - You won't fall into the void",
                Duration = 3,
            })
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Anti-Void",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})

CombatTab:CreateToggle({
    Name = 'Anti-Punch',
    CurrentValue = AntiFeatures_Enabled.AntiPunch,
    Callback = function(v)
        AntiFeatures_Enabled.AntiPunch = v
        
        if v then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Anti-Punch",
                Text = "Enabled - Attackers will be killed",
                Duration = 3,
            })
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Anti-Punch",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})

CombatTab:CreateToggle({
    Name = 'Auto Respawn',
    CurrentValue = AntiFeatures_Enabled.AutoRespawn,
    Callback = function(v)
        AntiFeatures_Enabled.AutoRespawn = v
        
        if v then
            -- Setup auto respawn on first enable
            if not autoRespawnSetup then
                setupAutoRespawn()
            end
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Respawn",
                Text = "Enabled - Will respawn quickly after death",
                Duration = 3,
            })
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Auto Respawn",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})

CombatTab:CreateToggle({
    Name = 'Anti-Tase',
    CurrentValue = AntiFeatures_Enabled.AntiTase,
    Callback = function(v)
        AntiFeatures_Enabled.AntiTase = v
        
        if v then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Anti-Tase",
                Text = "Enabled - Tase effects will be removed",
                Duration = 3,
            })
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Anti-Tase",
                Text = "Disabled",
                Duration = 3,
            })
        end
    end,
})



VisualsTab:CreateSection('Player ESP')
VisualsTab:CreateToggle({
    Name = 'Enable ESP',
    CurrentValue = Env.cfg.esp,
    Callback = function(v)
        Env.cfg.esp = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateToggle({
    Name = 'Team Check',
    CurrentValue = Env.cfg.espteamcheck,
    Callback = function(v)
        Env.cfg.espteamcheck = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateToggle({
    Name = 'Use Team Colors',
    CurrentValue = Env.cfg.espuseteamcolors,
    Callback = function(v)
        Env.cfg.espuseteamcolors = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateSlider({
    Name = 'Max Distance',
    Range = {50, 1000},
    Increment = 10,
    Suffix = 'm',
    CurrentValue = Env.cfg.espmaxdist,
    Callback = function(v)
        Env.cfg.espmaxdist = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateSection('Team Colors')
VisualsTab:CreateColorPicker({
    Name = 'Guards',
    Color = Env.cfg.espguards,
    Callback = function(v)
        Env.cfg.espguards = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateColorPicker({
    Name = 'Inmates',
    Color = Env.cfg.espinmates,
    Callback = function(v)
        Env.cfg.espinmates = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateColorPicker({
    Name = 'Criminals',
    Color = Env.cfg.espcriminals,
    Callback = function(v)
        Env.cfg.espcriminals = v

        Env.updateEsp()
    end,
})
VisualsTab:CreateSection('C4 ESP')
VisualsTab:CreateToggle({
    Name = 'Enable C4 ESP',
    CurrentValue = Env.cfg.c4esp,
    Callback = function(v)
        Env.cfg.c4esp = v

        Env.updateC4Esp()
    end,
})
VisualsTab:CreateColorPicker({
    Name = 'C4 Color',
    Color = Env.cfg.c4espcolor,
    Callback = function(v)
        Env.cfg.c4espcolor = v

        Env.updateC4Esp()
    end,
})

VisualsTab:CreateSection("Camera")

VisualsTab:CreateSlider({
    Name = "Camera FOV",
    Range = { 70, 120 },
    Increment = 1,
    CurrentValue = Workspace.CurrentCamera.FieldOfView,
    Callback = function(v)
        Workspace.CurrentCamera.FieldOfView = v
    end
})

local VisualsSection = VisualsTab:CreateSection("Visual Features")

local TracerToggle = VisualsTab:CreateToggle({
    Name = "Enable Tracers",
    CurrentValue = Env.cfg.tracer.enabled,
    Flag = "TracerToggle",
    Callback = function(Value)
        Env.cfg.tracer.enabled = Value
    end,
})

local TracerColor = VisualsTab:CreateColorPicker({
    Name = "Tracer Color",
    Color = Env.cfg.tracer.color,
    Flag = "TracerColor",
    Callback = function(Value)
        Env.cfg.tracer.color = Value
    end
})

local TracerThickness = VisualsTab:CreateSlider({
    Name = "Tracer Thickness",
    Range = {0.05, 0.5},
    Increment = 0.01,
    CurrentValue = Env.cfg.tracer.thickness,
    Flag = "TracerThickness",
    Callback = function(Value)
        Env.cfg.tracer.thickness = Value
    end,
})

local TracerLifetime = VisualsTab:CreateSlider({
    Name = "Tracer Lifetime",
    Range = {0.1, 1},
    Increment = 0.05,
    CurrentValue = Env.cfg.tracer.lifetime,
    Flag = "TracerLifetime",
    Callback = function(Value)
        Env.cfg.tracer.lifetime = Value
    end,
})

local TracerFade = VisualsTab:CreateSlider({
    Name = "Tracer Fade Duration",
    Range = {0.1, 1},
    Increment = 0.05,
    CurrentValue = Env.cfg.tracer.fade,
    Flag = "TracerFade",
    Callback = function(Value)
        Env.cfg.tracer.fade = Value
    end,
})

local HitSoundSection = VisualsTab:CreateSection("Hit Sound")

local HitSoundToggle = VisualsTab:CreateToggle({
    Name = "Enable Hit Sound",
    CurrentValue = Env.cfg.hitsound.enabled,
    Flag = "HitSoundToggle",
    Callback = function(Value)
        Env.cfg.hitsound.enabled = Value
    end,
})

local HitSoundVolume = VisualsTab:CreateSlider({
    Name = "Hit Sound Volume",
    Range = {0, 5},
    Increment = 0.1,
    CurrentValue = Env.cfg.hitsound.volume,
    Flag = "HitSoundVolume",
    Callback = function(Value)
        Env.cfg.hitsound.volume = Value
        HitSound.Volume = Value
    end,
})

local NormalHitSound = VisualsTab:CreateInput({
    Name = "Normal Hit Sound ID",
    PlaceholderText = "Asset ID",
    RemoveTextAfterFocusLost = false,
    CurrentValue = tostring(Env.cfg.hitsound.normal),
    Flag = "NormalHitSound",
    Callback = function(Value)
        local id = tonumber(Value)
        if id then
            Env.cfg.hitsound.normal = id
        end
    end,
})

local HeadshotSound = VisualsTab:CreateInput({
    Name = "Headshot Sound ID",
    PlaceholderText = "Asset ID",
    RemoveTextAfterFocusLost = false,
    CurrentValue = tostring(Env.cfg.hitsound.headshot),
    Flag = "HeadshotSound",
    Callback = function(Value)
        local id = tonumber(Value)
        if id then
            Env.cfg.hitsound.headshot = id
        end
    end,
})

local HitmarkerSection = VisualsTab:CreateSection("Hitmarker")

local HitmarkerToggle = VisualsTab:CreateToggle({
    Name = "Enable Hitmarker",
    CurrentValue = Env.cfg.hitmarker.enabled,
    Flag = "HitmarkerToggle",
    Callback = function(Value)
        Env.cfg.hitmarker.enabled = Value
    end,
})

local HitmarkerThickness = VisualsTab:CreateSlider({
    Name = "Hitmarker Thickness",
    Range = {1, 5},
    Increment = 0.5,
    CurrentValue = Env.cfg.hitmarker.thickness,
    Flag = "HitmarkerThickness",
    Callback = function(Value)
        Env.cfg.hitmarker.thickness = Value
    end,
})

local HitmarkerLength = VisualsTab:CreateSlider({
    Name = "Hitmarker Length",
    Range = {3, 15},
    Increment = 1,
    CurrentValue = Env.cfg.hitmarker.length,
    Flag = "HitmarkerLength",
    Callback = function(Value)
        Env.cfg.hitmarker.length = Value
    end,
})

local HitmarkerGap = VisualsTab:CreateSlider({
    Name = "Hitmarker Gap",
    Range = {1, 10},
    Increment = 1,
    CurrentValue = Env.cfg.hitmarker.gap,
    Flag = "HitmarkerGap",
    Callback = function(Value)
        Env.cfg.hitmarker.gap = Value
    end,
})

local CrosshairSection = VisualsTab:CreateSection("Crosshair")

local CustomCrosshair = VisualsTab:CreateInput({
    Name = "Custom Crosshair Image ID",
    PlaceholderText = "Asset ID (leave empty for default)",
    RemoveTextAfterFocusLost = false,
    CurrentValue = Env.cfg.crosshair.customImage,
    Flag = "CustomCrosshair",
    Callback = function(Value)
        Env.cfg.crosshair.customImage = Value
        updateCrosshair()
    end,
})

VisualsTab:CreateSection("World Aesthetics")

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local timeLoop
local desiredTime = 14
local freezeTime = false

VisualsTab:CreateToggle({
    Name = "Freeze Time (Bypass Game Cycle)",
    CurrentValue = false,
    Callback = function(v)
        freezeTime = v

        if v then
            timeLoop = RunService.RenderStepped:Connect(function()
                if freezeTime then
                    Lighting.ClockTime = desiredTime
                end
            end)
        else
            if timeLoop then
                timeLoop:Disconnect()
                timeLoop = nil
            end
        end
    end
})

VisualsTab:CreateSlider({
    Name = "Time of Day",
    Range = { 0, 24 },
    Increment = 0.5,
    CurrentValue = desiredTime,
    Callback = function(v)
        desiredTime = v
        if not freezeTime then
            Lighting.ClockTime = v
        end
    end
})

local ColorCorr =
    Lighting:FindFirstChild("CasualWorldTint")
    or Instance.new("ColorCorrectionEffect")

ColorCorr.Name = "CasualWorldTint"
ColorCorr.Parent = Lighting
ColorCorr.Enabled = false

VisualsTab:CreateToggle({
    Name = "Enable World Tint",
    CurrentValue = false,
    Callback = function(v)
        ColorCorr.Enabled = v
    end
})

VisualsTab:CreateColorPicker({
    Name = "Tint Color",
    Color = Color3.fromRGB(255, 255, 255),
    Callback = function(v)
        ColorCorr.TintColor = v
    end
})

VisualsTab:CreateSection("Lighting & Skybox")

VisualsTab:CreateLabel("Tip: Increase Ambient to see Sky at Night")

VisualsTab:CreateColorPicker({
    Name = "Ambient Color (Brightness)",
    Color = Lighting.Ambient,
    Callback = function(v)
        Lighting.Ambient = v
        Lighting.OutdoorAmbient = v
    end
})

local defaultSky = Lighting:FindFirstChildOfClass("Sky")

if not defaultSky then
    defaultSky = Instance.new("Sky")
    defaultSky.Name = "DefaultSky"
    defaultSky.Parent = Lighting
end

local origSky = {
    Bk = defaultSky.SkyboxBk,
    Dn = defaultSky.SkyboxDn,
    Ft = defaultSky.SkyboxFt,
    Lf = defaultSky.SkyboxLf,
    Rt = defaultSky.SkyboxRt,
    Up = defaultSky.SkyboxUp,
    Sun = defaultSky.SunTextureId,
    Moon = defaultSky.MoonTextureId,
    Stars = defaultSky.StarCount
}

local skyList = {
    ["Default"] = origSky,

    ["Purple Galaxy"] = {
        Bk = "http://www.roblox.com/asset/?id=159454299",
        Dn = "http://www.roblox.com/asset/?id=159454296",
        Ft = "http://www.roblox.com/asset/?id=159454293",
        Lf = "http://www.roblox.com/asset/?id=159454286",
        Rt = "http://www.roblox.com/asset/?id=159454300",
        Up = "http://www.roblox.com/asset/?id=159454288",
        Sun = "",
        Moon = "",
        Stars = 3000
    },

    ["Realism Sky"] = {
        Bk = "rbxassetid://2178907873",
        Dn = "rbxassetid://2178907663",
        Ft = "rbxassetid://2178906994",
        Lf = "rbxassetid://2178907310",
        Rt = "rbxassetid://2178906665",
        Up = "rbxassetid://2178907997",
        Sun = "",
        Moon = "",
        Stars = 0
    },

    ["Red Moon"] = {
        Bk = "rbxassetid://482655387",
        Dn = "rbxassetid://482655387",
        Ft = "rbxassetid://482655387",
        Lf = "rbxassetid://482655387",
        Rt = "rbxassetid://482655387",
        Up = "rbxassetid://482655387",
        Sun = "",
        Moon = "",
        Stars = 3000
    }
}

VisualsTab:CreateDropdown({
    Name = "Skybox Theme",
    Options = { "Default", "Purple Galaxy", "Realism Sky", "Red Moon" },
    CurrentOption = { "Default" },
    MultipleOptions = false,
    Callback = function(option)
        local data = skyList[option[1]]
        if not data then return end

        local sky = Lighting:FindFirstChildOfClass("Sky")
        if not sky then
            sky = Instance.new("Sky")
            sky.Parent = Lighting
        end

        sky.SkyboxBk = data.Bk
        sky.SkyboxDn = data.Dn
        sky.SkyboxFt = data.Ft
        sky.SkyboxLf = data.Lf
        sky.SkyboxRt = data.Rt
        sky.SkyboxUp = data.Up

        if data.Sun ~= nil then sky.SunTextureId = data.Sun end
        if data.Moon ~= nil then sky.MoonTextureId = data.Moon end
        if data.Stars ~= nil then sky.StarCount = data.Stars end
    end
})

VisualsTab:CreateSlider({
    Name = "Fog Distance",
    Range = { 0, 10000 },
    Increment = 10,
    CurrentValue = Lighting.FogEnd,
    Callback = function(v)
        Lighting.FogEnd = v
    end
})

MovementTab:CreateSection('Speed')
MovementTab:CreateToggle({
    Name = 'Enable WalkSpeed',
    CurrentValue = Env.cfg.ws_enabled,
    Callback = function(v)
        Env.cfg.ws_enabled = v
    end,
})
MovementTab:CreateSlider({
    Name = 'WalkSpeed',
    Range = {16, 200},
    Increment = 1,
    CurrentValue = Env.cfg.walkspeed,
    Callback = function(v)
        Env.cfg.walkspeed = v
    end,
})
MovementTab:CreateToggle({
    Name = 'Enable JumpPower',
    CurrentValue = Env.cfg.jp_enabled,
    Callback = function(v)
        Env.cfg.jp_enabled = v
    end,
})
MovementTab:CreateSlider({
    Name = 'JumpPower',
    Range = {50, 500},
    Increment = 1,
    CurrentValue = Env.cfg.jumppower,
    Callback = function(v)
        Env.cfg.jumppower = v
    end,
})
MovementTab:CreateSection('Physics')
MovementTab:CreateToggle({
    Name = 'Noclip',
    CurrentValue = Env.cfg.noclip,
    Callback = function(v)
        Env.cfg.noclip = v

        updateNoclip()
    end,
})

MovementTab:CreateSection('Teleports')

local function tp(pos)
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(pos)
    end
end

MovementTab:CreateButton({
    Name = 'Yard',
    Callback = function()
        tp(Vector3.new(780, 98, 2470))
    end,
})
MovementTab:CreateButton({
    Name = 'Prison Interior',
    Callback = function()
        tp(Vector3.new(913, 100, 2388))
    end,
})
MovementTab:CreateButton({
    Name = 'Armory',
    Callback = function()
        tp(Vector3.new(831, 100, 2233))
    end,
})
MovementTab:CreateButton({
    Name = 'Cafeteria',
    Callback = function()
        tp(Vector3.new(905, 100, 2316))
    end,
})
MovementTab:CreateButton({
    Name = 'Criminal Base',
    Callback = function()
        tp(Vector3.new(-931, 94, 2063))
    end,
})
MovementTab:CreateButton({
    Name = 'Instant Escape',
    Callback = function()
        local c = LocalPlayer.Character
        local h = c and c:FindFirstChild('HumanoidRootPart')

        if h then
            local containers = Workspace:FindFirstChild('Shippingcontainers')

            if containers then
                pcall(function()
                    h.CFrame = containers:GetChildren()[6]:GetChildren()[2].CFrame
                end)
            else
                h.CFrame = CFrame.new(-931, 94, 2063)
            end

            task.wait(0.5)

            local hum = c:FindFirstChild('Humanoid')

            if hum then
                hum.Health = 0
            end
        end
    end,
})

-- ============================================================================
-- ANIMATION PLAYER SYSTEM
-- ============================================================================

MovementTab:CreateSection('Animation Player')

-- Animation list
local AnimationsList = {
    {"Arm Turbine", "33169583"},
    {"Scared", "180612465"},
    {"Arm Deatch", "35978879"},
    {"Spinning Dance", "188632011"},
    {"Float Sit", "179224234"},
    {"Legs Crossed", "182724289"},
    {"Hero Slash", "184574340"},
    {"Float", "181526230"},
    {"Robot Dance", "40974665"},
    {"Faint", "181525546"},
    {"Insane Arms", "27432691"},
    {"Classic Ballet", "429730430"},
    {"Moonlight Dance", "45834924"},
    {"Clone Illusion", "215384594"},
    {"Floating Head", "121572214"},
    {"Slash Hug", "204295235"},
    {"Bow Down", "204292303"}
}

-- Create dropdown options from animations list
local AnimationOptions = {}
for _, anim in ipairs(AnimationsList) do
    table.insert(AnimationOptions, anim[1])
end

-- Animation state
local SelectedAnimId = nil
local SelectedAnimName = nil
local IsPlayingAnim = false
local IsLooping = true
local CurrentTrack = nil
local CurrentAnimator = nil

-- Helper functions
local function stopCurrentAnim()
    IsPlayingAnim = false
    if CurrentTrack then
        pcall(function() CurrentTrack:Stop() end)
        CurrentTrack = nil
    end
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animation Player",
        Text = "Animation stopped",
        Duration = 2,
    })
end

local function playAnimById(animId, animName)
    SelectedAnimId = animId
    SelectedAnimName = animName
    
    if not LocalPlayer.Character then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Animation Player",
            Text = "Waiting for character...",
            Duration = 2,
        })
        return
    end
    
    local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Animation Player",
            Text = "No humanoid found!",
            Duration = 2,
        })
        return
    end
    
    -- Stop previous track
    if CurrentTrack then
        pcall(function() CurrentTrack:Stop() end)
        CurrentTrack = nil
    end
    
    -- Ensure animator exists
    CurrentAnimator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    
    -- Create animation instance
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. tostring(animId)
    
    -- Load and play
    local ok, track = pcall(function() return CurrentAnimator:LoadAnimation(anim) end)
    if not ok or not track then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Animation Player",
            Text = "Failed to load animation!",
            Duration = 2,
        })
        CurrentTrack = nil
        return
    end
    
    CurrentTrack = track
    CurrentTrack.Looped = IsLooping
    
    -- Special case for "Insane Arms"
    if animName == "Insane Arms" then
        pcall(function() CurrentTrack:Play(0.1, 1, 100000000) end)
    else
        pcall(function() CurrentTrack:Play() end)
    end
    
    IsPlayingAnim = true
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Animation Player",
        Text = "Playing: " .. animName,
        Duration = 2,
    })
end

-- UI Elements
MovementTab:CreateDropdown({
    Name = 'Select Animation',
    Options = AnimationOptions,
    Callback = function(Option)
        local selectedName = Option[1]
        -- Find the animation ID
        for _, anim in ipairs(AnimationsList) do
            if anim[1] == selectedName then
                SelectedAnimId = anim[2]
                SelectedAnimName = anim[1]
                break
            end
        end
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Animation Player",
            Text = "Selected: " .. selectedName,
            Duration = 2,
        })
    end,
})

MovementTab:CreateToggle({
    Name = 'Play Animation',
    CurrentValue = false,
    Callback = function(v)
        if v then
            if not SelectedAnimId then
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "Animation Player",
                    Text = "Please select an animation first!",
                    Duration = 2,
                })
                return
            end
            playAnimById(SelectedAnimId, SelectedAnimName)
        else
            stopCurrentAnim()
        end
    end,
})

MovementTab:CreateToggle({
    Name = 'Loop Animation',
    CurrentValue = true,
    Callback = function(v)
        IsLooping = v
        -- Apply to current track
        if CurrentTrack then
            pcall(function() CurrentTrack.Looped = IsLooping end)
        end
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Animation Player",
            Text = "Loop: " .. (v and "ON" or "OFF"),
            Duration = 2,
        })
    end,
})

MovementTab:CreateButton({
    Name = 'Stop Animation',
    Callback = function()
        stopCurrentAnim()
    end,
})

-- Reapply playback on character respawn if toggled on
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.1)
    if IsPlayingAnim and SelectedAnimId and SelectedAnimName then
        playAnimById(SelectedAnimId, SelectedAnimName)
    end
end)

-- ============================================================================
-- TOUCH FLING SYSTEM
-- ============================================================================

MovementTab:CreateSection('Touch Fling')

local hiddenFling = false
local flingPower = 25000
local sliderDragging = false

MovementTab:CreateToggle({
    Name = 'Enable Touch Fling',
    CurrentValue = false,
    Callback = function(v)
        hiddenFling = v
        
        if v then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Touch Fling",
                Text = "Enabled - Touch players to fling them",
                Duration = 2,
            })
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Touch Fling",
                Text = "Disabled",
                Duration = 2,
            })
        end
    end,
})

MovementTab:CreateSlider({
    Name = 'Fling Power',
    Range = {5000, 55000},
    Increment = 1000,
    CurrentValue = flingPower,
    Callback = function(v)
        flingPower = v
    end,
})

-- Touch fling loop
task.spawn(function()
    local lp = Players.LocalPlayer
    local hrp, char, vel, movel = nil, nil, nil, 0.1
    
    while true do
        RunService.Heartbeat:Wait()
        if hiddenFling then
            while hiddenFling and not (char and char.Parent and hrp and hrp.Parent) do
                RunService.Heartbeat:Wait()
                char = lp.Character
                hrp = char and char:FindFirstChild("HumanoidRootPart")
            end
            
            if hiddenFling and hrp and hrp.Parent then
                vel = hrp.Velocity
                pcall(function()
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                end)
                RunService.RenderStepped:Wait()
                
                if char and char.Parent and hrp and hrp.Parent then
                    pcall(function() hrp.Velocity = vel end)
                end
                RunService.Stepped:Wait()
                
                if char and char.Parent and hrp and hrp.Parent then
                    pcall(function()
                        hrp.Velocity = vel + Vector3.new(0, movel, 0)
                    end)
                    movel = movel * -1
                end
            end
        end
    end
end)

-- ============================================================================
-- ARENA SYSTEM (Moving Floor)
-- ============================================================================

MovementTab:CreateSection('Arena')

local arenaEnabled = false
local centerY = 124.981201171875
local tileSize = 2048
local floorPart = nil
local renderConnection = nil

local function getPlayerPosition()
    local char = LocalPlayer.Character
    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then return hrp.Position end
    end
    return nil
end

local function createArena()
    if floorPart then return end
    
    floorPart = Instance.new("Part")
    floorPart.Name = "ArenaFloor"
    floorPart.Anchored = true
    floorPart.CanCollide = true
    floorPart.Transparency = 0.1
    floorPart.Color = Color3.fromRGB(120, 120, 120)
    floorPart.Size = Vector3.new(tileSize, 1, tileSize)
    floorPart.Parent = Workspace
    
    renderConnection = RunService.RenderStepped:Connect(function()
        local pos = getPlayerPosition()
        if not pos then return end
        local snappedX = math.floor(pos.X / tileSize + 0.5) * tileSize
        local snappedZ = math.floor(pos.Z / tileSize + 0.5) * tileSize
        floorPart.Position = Vector3.new(snappedX, centerY, snappedZ)
    end)
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Arena",
        Text = "Arena floor created",
        Duration = 2,
    })
end

local function destroyArena()
    if renderConnection then
        renderConnection:Disconnect()
        renderConnection = nil
    end
    if floorPart then
        floorPart:Destroy()
        floorPart = nil
    end
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Arena",
        Text = "Arena floor destroyed",
        Duration = 2,
    })
end

MovementTab:CreateToggle({
    Name = 'Enable Arena',
    CurrentValue = false,
    Callback = function(v)
        arenaEnabled = v
        if arenaEnabled then
            createArena()
        else
            destroyArena()
        end
    end,
})

MovementTab:CreateSlider({
    Name = 'Arena Height (Y)',
    Range = {0, 200},
    Increment = 1,
    CurrentValue = centerY,
    Callback = function(v)
        centerY = v
    end,
})

MovementTab:CreateSlider({
    Name = 'Arena Size',
    Range = {512, 4096},
    Increment = 128,
    CurrentValue = tileSize,
    Callback = function(v)
        tileSize = v
        -- Update floor size if it exists
        if floorPart then
            floorPart.Size = Vector3.new(tileSize, 1, tileSize)
        end
    end,
})

-- ============================================================================

VehicleTab:CreateSection('Vehicle Modifications')
VehicleTab:CreateToggle({
    Name = 'Enable Vehicle Mods',
    CurrentValue = Env.cfg.vehicle.enabled,
    Callback = function(v)
        Env.cfg.vehicle.enabled = v

        if v then
            getgenv().startVehicleMonitoring()
        else
            getgenv().stopVehicleMonitoring()
        end
    end,
})
VehicleTab:CreateSlider({
    Name = 'Max Speed',
    Range = {10, 200},
    Increment = 5,
    CurrentValue = Env.cfg.vehicle.maxSpeed,
    Callback = function(v)
        Env.cfg.vehicle.maxSpeed = v
    end,
})
VehicleTab:CreateSlider({
    Name = 'Turn Speed',
    Range = {0.5, 5},
    Increment = 0.1,
    CurrentValue = Env.cfg.vehicle.turnSpeed,
    Callback = function(v)
        Env.cfg.vehicle.turnSpeed = v
    end,
})
VehicleTab:CreateSlider({
    Name = 'Torque',
    Range = {10, 200},
    Increment = 5,
    CurrentValue = Env.cfg.vehicle.torque,
    Callback = function(v)
        Env.cfg.vehicle.torque = v
    end,
})
VehicleTab:CreateSlider({
    Name = 'Steer Responsiveness',
    Range = {0.1, 2},
    Increment = 0.1,
    CurrentValue = Env.cfg.vehicle.steerFloat,
    Callback = function(v)
        Env.cfg.vehicle.steerFloat = v
    end,
})
VehicleTab:CreateSection('Vehicle Flight')

local RunService = game:GetService('RunService')
local Players = game:GetService('Players')
local Workspace = game:GetService('Workspace')
local Player = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local FlyEnabled = false
local FlySpeed = 150

VehicleTab:CreateToggle({
    Name = 'Enable Vehicle Fly',
    CurrentValue = false,
    Flag = 'FlyToggle',
    Callback = function(Value)
        FlyEnabled = Value

        if not FlyEnabled then
            local char = Player.Character

            if char then
                local hum = char:FindFirstChild('Humanoid')

                if hum and hum.SeatPart then
                    local s = hum.SeatPart

                    if s:FindFirstChild('FlyVelocity') then
                        s.FlyVelocity:Destroy()
                    end
                    if s:FindFirstChild('FlyGyro') then
                        s.FlyGyro:Destroy()
                    end
                end
            end
        end
    end,
})
VehicleTab:CreateSlider({
    Name = 'Fly Speed',
    Range = {0, 500},
    Increment = 10,
    Suffix = 'Speed',
    CurrentValue = 150,
    Flag = 'SpeedSlider',
    Callback = function(Value)
        FlySpeed = Value
    end,
})

local function setupVehicle(seat)
    local bv = seat:FindFirstChild('FlyVelocity') or Instance.new('BodyVelocity')

    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.zero
    bv.Name = 'FlyVelocity'
    bv.Parent = seat

    local bg = seat:FindFirstChild('FlyGyro') or Instance.new('BodyGyro')

    bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bg.P = 3000
    bg.D = 100
    bg.CFrame = seat.CFrame
    bg.Name = 'FlyGyro'
    bg.Parent = seat

    return bv, bg
end

RunService.Heartbeat:Connect(function()
    if not FlyEnabled then
        return
    end

    local character = Player.Character

    if not character then
        return
    end

    local humanoid = character:FindFirstChild('Humanoid')

    if not humanoid then
        return
    end

    local seat = humanoid.SeatPart

    if seat and seat:IsA('VehicleSeat') then
        if Camera.CameraSubject ~= humanoid then
            Camera.CameraSubject = humanoid
        end

        seat.AssemblyLinearVelocity = Vector3.zero

        local bv, bg = setupVehicle(seat)
        local throttle = seat.Throttle
        local steer = seat.Steer

        if math.abs(throttle) > 0 then
            bv.Velocity = Camera.CFrame.LookVector * (throttle * FlySpeed)
            bg.CFrame = Camera.CFrame * CFrame.Angles(0, 0, -steer * 0.5)
        else
            bv.Velocity = Vector3.zero
            bg.CFrame = seat.CFrame
        end
    end
end)

-- ============================================================================
-- CAR JUMP SYSTEM
-- ============================================================================

VehicleTab:CreateSection('Car Jump')

local JUMP_FORCE = 120
local FORWARD_BOOST = 80
local carJumpEnabled = false
local carInputConn = nil
local UIS = game:GetService("UserInputService")

local function getVehicleSeat()
    local character = LocalPlayer.Character
    if not character then return nil end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return nil end
    local seat = humanoid.SeatPart
    if seat and seat:IsA("VehicleSeat") then
        return seat
    end
    return nil
end

local function carInputHandler(input, gameProcessed)
    if gameProcessed then return end
    if not carJumpEnabled then return end
    if input.KeyCode == Enum.KeyCode.LeftAlt then
        local seat = getVehicleSeat()
        if not seat then return end
        local car = seat.Parent
        local root = car:FindFirstChild("PrimaryPart") or car:FindFirstChildWhichIsA("BasePart")
        if not root then return end
        local vel = root.AssemblyLinearVelocity or Vector3.new()
        local forward = root.CFrame.LookVector
        pcall(function()
            root.AssemblyLinearVelocity = Vector3.new(
                vel.X + forward.X * FORWARD_BOOST,
                JUMP_FORCE,
                vel.Z + forward.Z * FORWARD_BOOST
            )
        end)
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Car Jump",
            Text = "Car jumped!",
            Duration = 1,
        })
    end
end

VehicleTab:CreateToggle({
    Name = 'Enable Car Jump',
    CurrentValue = false,
    Callback = function(v)
        carJumpEnabled = v
        
        if carJumpEnabled then
            if not carInputConn then
                carInputConn = UIS.InputBegan:Connect(carInputHandler)
            end
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Car Jump",
                Text = "Enabled - Press Left Alt to jump",
                Duration = 3,
            })
        else
            if carInputConn then
                carInputConn:Disconnect()
                carInputConn = nil
            end
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Car Jump",
                Text = "Disabled",
                Duration = 2,
            })
        end
    end,
})

VehicleTab:CreateSlider({
    Name = 'Jump Force',
    Range = {50, 300},
    Increment = 10,
    CurrentValue = JUMP_FORCE,
    Callback = function(v)
        JUMP_FORCE = v
    end,
})

VehicleTab:CreateSlider({
    Name = 'Forward Boost',
    Range = {0, 200},
    Increment = 10,
    CurrentValue = FORWARD_BOOST,
    Callback = function(v)
        FORWARD_BOOST = v
    end,
})

-- ============================================================================

UtilityTab:CreateSection('Bypass')
UtilityTab:CreateToggle({
    Name = 'Walk While Arrested',
    CurrentValue = Env.cfg.shootarrested,
    Callback = function(v)
        Env.cfg.shootarrested = v
    end,
})
UtilityTab:CreateSection('Item Pickup')
UtilityTab:CreateToggle({
    Name = 'Auto Grab Items',
    CurrentValue = Env.cfg.autograb,
    Callback = function(v)
        Env.cfg.autograb = v
    end,
})

-- ============================================================================
-- PART CONTROL SYSTEM (ACTUALLY FIXED - STOPS WHEN DISABLED)
-- ============================================================================

UtilityTab:CreateSection('Part Control')

local PC_enabled = false
local PC_config = {
    radius = 50,
    height = 10,
    rotationSpeed = 10,
    attractionStrength = 1000,
    targetMode = "player",
    targetPlayer = nil,
    targetPart = nil
}
UtilityTab:CreateToggle({
    Name = "Auto Rejoin (IsBadGuard)",
    CurrentValue = false,
    Flag = "AutoRejoinBadGuard",
    Callback = function(state)
        local Players = game:GetService("Players")
        local TeleportService = game:GetService("TeleportService")

        local player = Players.LocalPlayer
        local placeId = game.PlaceId
        local jobId = game.JobId

        if not getgenv().BadGuardConnection then
            getgenv().BadGuardConnection = nil
        end

        local function rejoin()
            if queue_on_teleport then
                queue_on_teleport([[loadstring(game:HttpGet("https://raw.githubusercontent.com/Nahallia/Cc/refs/heads/main/P3.luau"))()]])
            end
            TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
        end

        if state then
            if player:GetAttribute("IsBadGuard") == true then
                rejoin()
                return
            end

            getgenv().BadGuardConnection =
                player:GetAttributeChangedSignal("IsBadGuard"):Connect(function()
                    if player:GetAttribute("IsBadGuard") == true then
                        rejoin()
                    end
                end)
        else
            if getgenv().BadGuardConnection then
                getgenv().BadGuardConnection:Disconnect()
                getgenv().BadGuardConnection = nil
            end
        end
    end,
})

UtilityTab:CreateButton({
    Name = "Server Hop",
    Callback = function()
        local Players = game:GetService("Players")
        local TeleportService = game:GetService("TeleportService")

        local player = Players.LocalPlayer

        if queue_on_teleport then
            queue_on_teleport([[loadstring(game:HttpGet("https://raw.githubusercontent.com/Nahallia/Cc/refs/heads/main/P3.luau"))()]])
        end

        TeleportService:Teleport(game.PlaceId, player)
    end,
})

-- Part tracking system


-- ============================================================================
-- PLAYER ACTIONS (VIEW, TELEPORT, HEADSTAND, ARM HOLD, ANNOY)
-- ============================================================================

UtilityTab:CreateSection('Player Actions')

local SelectedActionTarget = nil
local viewing = false
local attachConnection = nil
local headOn = false
local armOn = false
local annoyOn = false

local function stopAttach()
    if attachConnection then
        attachConnection:Disconnect()
        attachConnection = nil
    end
end

local function startAttach(partName, offset)
    stopAttach()
    if not SelectedActionTarget or not SelectedActionTarget.Character or not LocalPlayer.Character then return end
    
    local function getPart()
        local ch = SelectedActionTarget.Character
        return ch:FindFirstChild(partName)
    end
    
    attachConnection = RunService.Heartbeat:Connect(function()
        local targetPart = getPart()
        local mHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetPart and mHRP then
            mHRP.CFrame = targetPart.CFrame * offset
        end
    end)
end

-- Player selector
local ActionPlayerDropdown = UtilityTab:CreateDropdown({
    Name = 'Select Player',
    Options = {},
    CurrentOption = {},
    MultipleOptions = false,
    Callback = function(o)
        local playerName = o[1]
        SelectedActionTarget = Players:FindFirstChild(playerName)
        
        if SelectedActionTarget then
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Player Actions",
                Text = "Selected: " .. playerName,
                Duration = 2,
            })
        end
    end,
})

-- Spectate/View button
UtilityTab:CreateButton({
    Name = 'Spectate Player',
    Callback = function()
        if viewing then
            Workspace.CurrentCamera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            viewing = false
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Spectate",
                Text = "Stopped spectating",
                Duration = 2,
            })
        else
            if SelectedActionTarget and SelectedActionTarget.Character then
                local hum = SelectedActionTarget.Character:FindFirstChildOfClass("Humanoid")
                if hum then
                    Workspace.CurrentCamera.CameraSubject = hum
                    viewing = true
                    
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = "Spectate",
                        Text = "Spectating: " .. SelectedActionTarget.Name,
                        Duration = 2,
                    })
                end
            end
        end
    end,
})

-- Teleport button
UtilityTab:CreateButton({
    Name = 'Teleport to Player',
    Callback = function()
        if SelectedActionTarget and SelectedActionTarget.Character and LocalPlayer.Character then
            local tHRP = SelectedActionTarget.Character:FindFirstChild("HumanoidRootPart")
            local mHRP = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if tHRP and mHRP then
                mHRP.CFrame = tHRP.CFrame * CFrame.new(0, 0, 2)
                
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = "Teleport",
                    Text = "Teleported to " .. SelectedActionTarget.Name,
                    Duration = 2,
                })
            end
        end
    end,
})

-- Headstand toggle
UtilityTab:CreateToggle({
    Name = 'Headstand on Player',
    CurrentValue = false,
    Callback = function(v)
        headOn = v
        if headOn then
            startAttach("HumanoidRootPart", CFrame.new(0, 3, 0))
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Headstand",
                Text = "Headstand enabled",
                Duration = 2,
            })
        else
            stopAttach()
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Headstand",
                Text = "Headstand disabled",
                Duration = 2,
            })
        end
    end,
})

-- Arm hold toggle
UtilityTab:CreateToggle({
    Name = 'Hold Player Arm',
    CurrentValue = false,
    Callback = function(v)
        armOn = v
        if armOn then
            local ch = SelectedActionTarget and SelectedActionTarget.Character
            if ch then
                local arm = ch:FindFirstChild("RightHand") or ch:FindFirstChild("Right Arm")
                if arm then
                    startAttach(arm.Name, CFrame.new(0, 0, 0))
                    
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = "Arm Hold",
                        Text = "Holding arm",
                        Duration = 2,
                    })
                end
            end
        else
            stopAttach()
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Arm Hold",
                Text = "Released arm",
                Duration = 2,
            })
        end
    end,
})

-- Annoy toggle
UtilityTab:CreateToggle({
    Name = 'Annoy Player',
    CurrentValue = false,
    Callback = function(v)
        annoyOn = v
        if annoyOn then
            startAttach("Head", CFrame.new(0, 0, -0.6))
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Annoy",
                Text = "Annoy mode enabled",
                Duration = 2,
            })
        else
            stopAttach()
            
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Annoy",
                Text = "Annoy mode disabled",
                Duration = 2,
            })
        end
    end,
})

-- Update player list function
local function updateActionPlayerList()
    local playerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    ActionPlayerDropdown:Refresh(playerNames, true)
end

-- Refresh button
UtilityTab:CreateButton({
    Name = 'Refresh Player List',
    Callback = function()
        updateActionPlayerList()
        
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Player Actions",
            Text = "Player list refreshed",
            Duration = 2,
        })
    end,
})

-- Initialize player list
updateActionPlayerList()

-- Auto-update when players join/leave
Players.PlayerAdded:Connect(updateActionPlayerList)
Players.PlayerRemoving:Connect(updateActionPlayerList)

-- ============================================================================

ConfigTab:CreateSection('Configuration Manager')

local configNameInput = ''

ConfigTab:CreateInput({
    Name = 'Config Name',
    PlaceholderText = 'Enter config name...',
    RemoveTextAfterFocusLost = false,
    Callback = function(t)
        configNameInput = t
    end,
})
ConfigTab:CreateButton({
    Name = 'Save Config',
    Callback = function()
        if configNameInput == '' then
            Rayfield:Notify({
                Title = 'Config',
                Content = 'Please enter a config name!',
                Duration = 3,
            })

            return
        end
        if saveConfig(configNameInput) then
            Rayfield:Notify({
                Title = 'Config Saved',
                Content = 'Saved: ' .. configNameInput,
                Duration = 3,
            })
        else
            Rayfield:Notify({
                Title = 'Config Error',
                Content = 'Failed to save config!',
                Duration = 3,
            })
        end
    end,
})
ConfigTab:CreateButton({
    Name = 'Load Config',
    Callback = function()
        if configNameInput == '' then
            Rayfield:Notify({
                Title = 'Config',
                Content = 'Please enter a config name!',
                Duration = 3,
            })

            return
        end
        if loadConfig(configNameInput) then
            Rayfield:Notify({
                Title = 'Config Loaded',
                Content = 'Loaded: ' .. configNameInput,
                Duration = 3,
            })
        else
            Rayfield:Notify({
                Title = 'Config Error',
                Content = 'Config not found!',
                Duration = 3,
            })
        end
    end,
})

-- PL Features - Selected Players
local selectedVoidPlayer = nil
local selectedCarFlingPlayer = nil
local selectedBringPlayer = nil
local selectedTrapPlayer = nil

-- Helper function to get player list
local function GetPlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

-- ============================================================================
-- VOID SECTION
-- ============================================================================
UtilityTab:CreateSection('Void Players')

local VoidPlayerDropdown = UtilityTab:CreateDropdown({
    Name = 'Select Player to Void',
    Options = GetPlayerList(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = 'VoidPlayerDropdown',
    Callback = function(Option)
        if Option and Option[1] then
            selectedVoidPlayer = Players:FindFirstChild(Option[1])
        end
    end,
})

UtilityTab:CreateButton({
    Name = 'Void Selected Player',
    Callback = function()
        if selectedVoidPlayer and selectedVoidPlayer.Character then
            pcall(function()
                local tempo = LocalPlayer.Character.HumanoidRootPart.CFrame
                PL_BringPL(selectedVoidPlayer, CFrame.new(0, 9e9, 0), true, true)
                task.wait(0.6)
                
                if LocalPlayer.TeamColor == BrickColor.new("Bright blue") then
                    workspace.Remote.TeamEvent:FireServer("Bright blue")
                else
                    workspace.Remote.TeamEvent:FireServer("Bright orange")
                end
                
                LocalPlayer.CharacterAdded:Wait()
                wait(0.5)
                PL_LocTP(tempo)
                PL_Notif("Success", "Voided " .. selectedVoidPlayer.Name)
            end)
        else
            PL_Notif("Error", "No valid player selected")
        end
    end,
})

UtilityTab:CreateToggle({
    Name = 'Loop Void Selected Player',
    CurrentValue = false,
    Flag = 'LoopVoid',
    Callback = function(Value)
        if selectedVoidPlayer then
            if Value then
                PLFeatures_Loops.Voided[selectedVoidPlayer.UserId] = selectedVoidPlayer
                PL_Notif("Loop Void", "Started on " .. selectedVoidPlayer.Name)
            else
                PLFeatures_Loops.Voided[selectedVoidPlayer.UserId] = nil
                PL_Notif("Loop Void", "Stopped on " .. selectedVoidPlayer.Name)
            end
        else
            PL_Notif("Error", "No player selected")
        end
    end,
})

-- ============================================================================
-- CAR FLING SECTION
-- ============================================================================
UtilityTab:CreateSection('Car Fling Players')

local CarFlingPlayerDropdown = UtilityTab:CreateDropdown({
    Name = 'Select Player to Car Fling',
    Options = GetPlayerList(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = 'CarFlingPlayerDropdown',
    Callback = function(Option)
        if Option and Option[1] then
            selectedCarFlingPlayer = Players:FindFirstChild(Option[1])
        end
    end,
})

UtilityTab:CreateButton({
    Name = 'Car Fling Selected Player',
    Callback = function()
        if selectedCarFlingPlayer and selectedCarFlingPlayer.Character then
            PL_CarFlingPL(selectedCarFlingPlayer)
        else
            PL_Notif("Error", "No valid player selected")
        end
    end,
})

UtilityTab:CreateToggle({
    Name = 'Loop Car Fling Selected Player',
    CurrentValue = false,
    Flag = 'LoopCarFling',
    Callback = function(Value)
        if selectedCarFlingPlayer then
            if Value then
                PLFeatures_Loops.CarFling[selectedCarFlingPlayer.UserId] = selectedCarFlingPlayer
                PL_Notif("Loop Fling", "Started on " .. selectedCarFlingPlayer.Name)
            else
                PLFeatures_Loops.CarFling[selectedCarFlingPlayer.UserId] = nil
                PL_Notif("Loop Fling", "Stopped on " .. selectedCarFlingPlayer.Name)
            end
        else
            PL_Notif("Error", "No player selected")
        end
    end,
})

-- ============================================================================
-- BRING SECTION
-- ============================================================================
UtilityTab:CreateSection('Bring Players')

local BringPlayerDropdown = UtilityTab:CreateDropdown({
    Name = 'Select Player to Bring',
    Options = GetPlayerList(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = 'BringPlayerDropdown',
    Callback = function(Option)
        if Option and Option[1] then
            selectedBringPlayer = Players:FindFirstChild(Option[1])
        end
    end,
})

UtilityTab:CreateButton({
    Name = 'Bring Selected Player',
    Callback = function()
        if selectedBringPlayer and selectedBringPlayer.Character then
            PL_BringPL(selectedBringPlayer, LocalPlayer)
        else
            PL_Notif("Error", "No valid player selected")
        end
    end,
})

-- ============================================================================
-- TRAP SECTION
-- ============================================================================
UtilityTab:CreateSection('Trap Players')

local TrapPlayerDropdown = UtilityTab:CreateDropdown({
    Name = 'Select Player to Trap',
    Options = GetPlayerList(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = 'TrapPlayerDropdown',
    Callback = function(Option)
        if Option and Option[1] then
            selectedTrapPlayer = Players:FindFirstChild(Option[1])
        end
    end,
})

UtilityTab:CreateToggle({
    Name = 'Loop Trap Selected Player',
    CurrentValue = false,
    Flag = 'LoopTrap',
    Callback = function(Value)
        if selectedTrapPlayer then
            if Value then
                PLFeatures_Loops.Trapped[selectedTrapPlayer.UserId] = selectedTrapPlayer
                PL_Notif("Loop Trap", "Started on " .. selectedTrapPlayer.Name)
            else
                PLFeatures_Loops.Trapped[selectedTrapPlayer.UserId] = nil
                PL_Notif("Loop Trap", "Stopped on " .. selectedTrapPlayer.Name)
            end
        else
            PL_Notif("Error", "No player selected")
        end
    end,
})

-- ============================================================================
-- CAR UTILITIES SECTION
-- ============================================================================
UtilityTab:CreateSection('Car Utilities')

UtilityTab:CreateButton({
    Name = 'Bring Car (BCar)',
    Callback = function()
        pcall(function()
            PL_BringCar(nil, true)
            if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and 
                    LocalPlayer.Character.Humanoid.Sit) then
                PL_BringCar(nil, false)
            end
        end)
    end,
})

-- ============================================================================
-- REFRESH SECTION
-- ============================================================================
UtilityTab:CreateSection('Refresh Player Lists')

UtilityTab:CreateButton({
    Name = 'Refresh All Player Lists',
    Callback = function()
        pcall(function()
            local newPlayerList = GetPlayerList()
            VoidPlayerDropdown:Refresh(newPlayerList, true)
            CarFlingPlayerDropdown:Refresh(newPlayerList, true)
            BringPlayerDropdown:Refresh(newPlayerList, true)
            TrapPlayerDropdown:Refresh(newPlayerList, true)
            PL_Notif("Success", "Player lists refreshed")
        end)
    end,
})

-- Auto refresh on player join/leave
Players.PlayerAdded:Connect(function()
    task.wait(0.5)
    pcall(function()
        local newPlayerList = GetPlayerList()
        VoidPlayerDropdown:Refresh(newPlayerList, true)
        CarFlingPlayerDropdown:Refresh(newPlayerList, true)
        BringPlayerDropdown:Refresh(newPlayerList, true)
        TrapPlayerDropdown:Refresh(newPlayerList, true)
    end)
end)

Players.PlayerRemoving:Connect(function()
    task.wait(0.5)
    pcall(function()
        local newPlayerList = GetPlayerList()
        VoidPlayerDropdown:Refresh(newPlayerList, true)
        CarFlingPlayerDropdown:Refresh(newPlayerList, true)
        BringPlayerDropdown:Refresh(newPlayerList, true)
        TrapPlayerDropdown:Refresh(newPlayerList, true)
    end)
end)

ConfigTab:CreateSection('Reset')
ConfigTab:CreateButton({
    Name = 'Reset to Defaults',
    Callback = function()
        Env.cfg.enabled = true
        Env.cfg.teamcheck = false
        Env.cfg.esp = false
        Env.cfg.autoarrest = false
        Env.cfg.punchaura = false
        Env.cfg.noclip = false
        Env.cfg.shootarrested = false
        Env.cfg.autograb = false
        Env.cfg.ws_enabled = false
        Env.cfg.jp_enabled = false

        updateNoclip()
        Env.updateEsp()
        Rayfield:Notify({
            Title = 'Reset Complete',
            Content = 'All settings restored to default',


            Duration = 3,
        })
    end,
})
Rayfield:Notify({
    Title = 'Welcome!',
    Content = 'Casual Comas v' .. Env.Version,
    Duration = 5,
})


-- =====================================================================
-- PASTE THIS AT THE VERY END OF MAIN5.LUA (BEFORE THE --]] IF IT EXISTS)
-- =====================================================================

pcall(function()

local success, result = pcall(function()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

wait(1) -- Wait for everything to load

local player = Players.LocalPlayer
if not player then return end

local playerGui = player:WaitForChild("PlayerGui", 10)
if not playerGui then return end

local gui = Instance.new("ScreenGui")
gui.Parent = playerGui
gui.IgnoreGuiInset = true
gui.ResetOnSpawn = false
gui.Name = "VehicleSpeedGUI_FINAL"
gui.Enabled = false

local vehicleLoop = nil
local currentIntensity = 0

local function applyVehicleSpeed(intensity)
	pcall(function()
		if vehicleLoop then
			vehicleLoop:Disconnect()
			vehicleLoop = nil
		end
		
		currentIntensity = intensity
		
		if intensity == 0 then return end
		
		vehicleLoop = RunService.Stepped:Connect(function()
			pcall(function()
				local cam = workspace.CurrentCamera
				if not cam then return end
				
				local subject = cam.CameraSubject
				if not subject then return end
				
				if subject:IsA("Humanoid") then
					local seat = subject.SeatPart
					if seat and seat:IsA("BasePart") then
						local dir = seat.CFrame.LookVector
						seat:ApplyImpulse(dir * Vector3.new(intensity, intensity, intensity))
					end
				elseif subject:IsA("BasePart") then
					local dir = subject.CFrame.LookVector
					subject:ApplyImpulse(dir * Vector3.new(intensity, intensity, intensity))
				end
			end)
		end)
	end)
end

local function stopVehicleSpeed()
	pcall(function()
		if vehicleLoop then
			vehicleLoop:Disconnect()
			vehicleLoop = nil
		end
		currentIntensity = 0
	end)
end

local dotColors = {
	[250] = Color3.fromRGB(20, 60, 180),
	[750] = Color3.fromRGB(160, 120, 60),
	[2000] = Color3.fromRGB(20, 90, 40),
	[5000] = Color3.fromRGB(120, 60, 180),
	[7000] = Color3.fromRGB(200, 90, 20),
}

local dotHolder = Instance.new("Frame")
dotHolder.Parent = gui
dotHolder.Size = UDim2.new(0, 150, 0, 30)
dotHolder.Position = UDim2.new(1, -160, 0, 5)
dotHolder.BackgroundTransparency = 1

local layout = Instance.new("UIListLayout")
layout.Parent = dotHolder
layout.FillDirection = Enum.FillDirection.Horizontal
layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
layout.VerticalAlignment = Enum.VerticalAlignment.Center
layout.Padding = UDim.new(0, 8)

local function createDot(speed)
	pcall(function()
		local dot = Instance.new("Frame")
		dot.Parent = dotHolder
		dot.Size = UDim2.fromOffset(18, 18)
		dot.BackgroundColor3 = dotColors[speed]
		dot.BorderSizePixel = 0
		
		local c = Instance.new("UICorner")
		c.Parent = dot
		c.CornerRadius = UDim.new(1, 0)
		
		local glow = Instance.new("UIStroke")
		glow.Parent = dot
		glow.Thickness = 1.2
		glow.Color = Color3.fromRGB(255, 255, 255)
		glow.Transparency = 0.6
		
		local btn = Instance.new("TextButton")
		btn.Parent = dot
		btn.BackgroundTransparency = 1
		btn.Size = UDim2.fromScale(1, 1)
		btn.Text = ""
		
		btn.MouseEnter:Connect(function()
			pcall(function()
				TweenService:Create(dot, TweenInfo.new(0.12), {Size = UDim2.fromOffset(22, 22)}):Play()
			end)
		end)
		
		btn.MouseLeave:Connect(function()
			pcall(function()
				TweenService:Create(dot, TweenInfo.new(0.12), {Size = UDim2.fromOffset(18, 18)}):Play()
			end)
		end)
		
		btn.MouseButton1Click:Connect(function()
			pcall(function()
				applyVehicleSpeed(speed)
			end)
		end)
	end)
end

for _, spd in ipairs({250, 750, 2000, 5000, 7000}) do
	createDot(spd)
end

local buttonHolder = Instance.new("Frame")
buttonHolder.Parent = gui
buttonHolder.Size = UDim2.new(0, 120, 0, 40)
buttonHolder.Position = UDim2.new(1, -130, 0, 40)
buttonHolder.BackgroundTransparency = 1

local bl = Instance.new("UIListLayout")
bl.Parent = buttonHolder
bl.FillDirection = Enum.FillDirection.Horizontal
bl.HorizontalAlignment = Enum.HorizontalAlignment.Right
bl.VerticalAlignment = Enum.VerticalAlignment.Top
bl.Padding = UDim.new(0, 10)

local function applyGoldGradient(obj)
	pcall(function()
		local grad = Instance.new("UIGradient")
		grad.Parent = obj
		grad.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 220, 0)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 170, 0))
		})
		grad.Rotation = 90
	end)
end

local inputBox = Instance.new("TextBox")
inputBox.Parent = gui
inputBox.Size = UDim2.fromOffset(80, 24)
inputBox.Position = UDim2.new(1, -140, 0, 80)
inputBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
inputBox.TextColor3 = Color3.fromRGB(0, 0, 0)
inputBox.PlaceholderText = "Speed"
inputBox.Text = ""
inputBox.Visible = false
inputBox.ClearTextOnFocus = false
inputBox.TextSize = 14

local ic = Instance.new("UICorner")
ic.Parent = inputBox
ic.CornerRadius = UDim.new(0, 6)

local holdingF = false

local function createCircleButton(label, color, callback, isGold)
	pcall(function()
		local b = Instance.new("Frame")
		b.Parent = buttonHolder
		b.Size = UDim2.fromOffset(24, 24)
		b.BackgroundColor3 = color
		b.BorderSizePixel = 0
		
		local c = Instance.new("UICorner")
		c.Parent = b
		c.CornerRadius = UDim.new(1, 0)
		
		if isGold then
			applyGoldGradient(b)
		end
		
		local t = Instance.new("TextButton")
		t.Parent = b
		t.Size = UDim2.fromScale(1, 1)
		t.BackgroundTransparency = 1
		t.Text = label
		t.Font = Enum.Font.GothamSemibold
		t.TextSize = 13
		t.TextColor3 = Color3.fromRGB(255, 255, 255)
		
		t.MouseEnter:Connect(function()
			pcall(function()
				TweenService:Create(b, TweenInfo.new(0.12), {Size = UDim2.fromOffset(28, 28)}):Play()
			end)
		end)
		
		t.MouseLeave:Connect(function()
			pcall(function()
				TweenService:Create(b, TweenInfo.new(0.12), {Size = UDim2.fromOffset(24, 24)}):Play()
			end)
		end)
		
		if label == "F" then
			t.MouseButton1Down:Connect(function()
				pcall(function()
					holdingF = true
					
					task.spawn(function()
						while holdingF do
							pcall(function()
								b.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
							end)
							task.wait(0.1)
							pcall(function()
								b.BackgroundColor3 = Color3.fromRGB(255, 170, 0)
							end)
							task.wait(0.1)
						end
					end)
					
					task.delay(3, function()
						pcall(function()
							if holdingF then
								inputBox.Visible = true
								inputBox:CaptureFocus()
							end
						end)
					end)
				end)
			end)
			
			t.MouseButton1Up:Connect(function()
				pcall(function()
					holdingF = false
					b.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
				end)
			end)
		end
		
		t.MouseButton1Click:Connect(function()
			pcall(callback)
		end)
	end)
end

createCircleButton("F", Color3.fromRGB(255, 200, 0), function()
	if currentIntensity and currentIntensity > 0 then
		applyVehicleSpeed(currentIntensity * 2.5)
		task.delay(1.5, function()
			applyVehicleSpeed(currentIntensity)
		end)
	end
end, true)

createCircleButton("S", Color3.fromRGB(200, 60, 60), function()
	stopVehicleSpeed()
end, false)

inputBox.FocusLost:Connect(function(enterPressed)
	pcall(function()
		if enterPressed then
			local val = tonumber(inputBox.Text)
			if val then
				applyVehicleSpeed(val)
			end
		end
		inputBox.Visible = false
	end)
end)

local function getVehicleSeat()
	pcall(function()
		local character = player.Character
		if not character then return nil end
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if not humanoid then return nil end
		local seat = humanoid.SeatPart
		if seat and seat:IsA("VehicleSeat") then
			return seat
		end
	end)
	return nil
end

local function onCharacterAdded(character)
	pcall(function()
		local humanoid = character:WaitForChild("Humanoid", 10)
		if not humanoid then return end
		
		humanoid.Seated:Connect(function(isSeated, seat)
			pcall(function()
				if isSeated and seat and seat:IsA("VehicleSeat") then
					gui.Enabled = true
				else
					gui.Enabled = false
					inputBox.Visible = false
					stopVehicleSpeed()
				end
			end)
		end)
		
		task.wait(0.5)
		if humanoid.Sit then
			local seat = getVehicleSeat()
			if seat then
				gui.Enabled = true
			end
		end
	end)
end

if player.Character then
	onCharacterAdded(player.Character)
end

player.CharacterAdded:Connect(function(char)
	onCharacterAdded(char)
end)

local visible = true
UserInputService.InputBegan:Connect(function(i, gp)
	pcall(function()
		if gp then return end
		if i.KeyCode == Enum.KeyCode.G then
			visible = not visible
			dotHolder.Visible = visible
			buttonHolder.Visible = visible
			inputBox.Visible = false
		end
	end)
end)

print(" VEHICLE SPEED GUI LOADED SUCCESSFULLY - NO ERRORS")

end)

if not success then
	warn("Vehicle GUI Error:", result)
end

end)

--[[CC PART I(DEPENDENCY)

getgenv().PL_Hub = getgenv().PL_Hub or {}
local Env = getgenv().PL_Hub

Env.Version = "1.0.0"

Env.Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    StarterGui = game:GetService("StarterGui"),
    TweenService = game:GetService("TweenService"),
    CoreGui = game:GetService("CoreGui"),
    GuiService = game:GetService("GuiService"),
    Teams = game:GetService("Teams"),
    HttpService = game:GetService("HttpService"),
    Debris = game:GetService("Debris"),
    SoundService = game:GetService("SoundService")
}

local Players = Env.Services.Players
local LocalPlayer = Players.LocalPlayer

Env.Teams = {
    Guards = Env.Services.Teams:FindFirstChild("Guards"),
    Inmates = Env.Services.Teams:FindFirstChild("Inmates"),
    Criminals = Env.Services.Teams:FindFirstChild("Criminals")
}

Env.cfg = {
    enabled = false,
    teamcheck = true,
    wallcheck = true,
    deathcheck = true,
    ffcheck = true,
    hostilecheck = true,
    trespasscheck = true,
    vehiclecheck = true,
    criminalsnoinnmates = true,
    inmatesnocriminals = true,
    shieldbreaker = false,
    shieldfrontangle = 0.3,
    shieldrandomhead = false,
    shieldheadchance = 30,
    taserbypasshostile = false,
    taserbypasstrespass = false,
    taseralwayshit = false,
    ifplayerstill = false,
    stillthreshold = 0.5,
    hitchance = 100,
    hitchanceAutoOnly = false,
    missspread = 5,
    shotgunnaturalspread = false,
    shotgungamehandled = false,
    prioritizeclosest = false,
    targetstickiness = false,
    targetstickinessduration = 0.6,
    targetstickinessrandom = false,
    targetstickinessmin = 0.3,
    targetstickinessmax = 0.7,
    fov = 120,
    showfov = true,
    showtargetline = false,
    togglekey = Enum.KeyCode.RightShift,
    aimpart = "Head",
    randomparts = true,
    partslist = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "HumanoidRootPart"},
    esp = false,
    espteamcheck = true,
    espshowteam = false,
    esptargets = {guards = true, inmates = true, criminals = true},
    espmaxdist = 500,
    espshowdist = true,
    esptoggle = Enum.KeyCode.RightControl,
    espcolor = Color3.fromRGB(0, 170, 255),
    espguards = Color3.fromRGB(0, 170, 255),
    espinmates = Color3.fromRGB(255, 150, 50),
    espcriminals = Color3.fromRGB(255, 60, 60),
    espteam = Color3.fromRGB(60, 255, 60),
    espuseteamcolors = true,
    autoshoot = true,
    autoshootdelay = 0.12,
    autoshootstartdelay = 0.2,
    c4esp = false,
    c4esptoggle = Enum.KeyCode.B,
    c4espcolor = Color3.fromRGB(80, 255, 80),
    c4espmaxdist = 200,
    c4espshowdist = true,
    hitsound = {
        enabled = true,
        volume = 2,
        normal = 1129547534,
        headshot = 108290646184559
    },
    tracer = {
        enabled = true,
        color = Color3.fromRGB(255, 255, 255),
        thickness = 0.12,
        lifetime = 0.15,
        fade = 0.2
    },
    hitmarker = {
        enabled = true,
        thickness = 1.5,
        length = 6,
        gap = 3,
        expand = 8,
        headExpand = 14
    },
    crosshair = {
        customImage = ""
    }
}

Env.wallParams = RaycastParams.new()
Env.wallParams.FilterType = Enum.RaycastFilterType.Exclude
Env.wallParams.IgnoreWater = true
Env.wallParams.RespectCanCollide = false
Env.wallParams.CollisionGroup = "ClientBullet"

Env.vars = {
    currentGun = nil,
    rng = Random.new(),
    lastShotTime = 0,
    lastShotResult = false,
    currentTarget = nil,
    targetSwitchTime = 0,
    currentStickiness = 0
}

Env.partMap = {
    ["Torso"] = {"Torso", "UpperTorso", "LowerTorso"},
    ["LeftArm"] = {"Left Arm", "LeftUpperArm", "LeftLowerArm", "LeftHand"},
    ["RightArm"] = {"Right Arm", "RightUpperArm", "RightLowerArm", "RightHand"},
    ["LeftLeg"] = {"Left Leg", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot"},
    ["RightLeg"] = {"Right Leg", "RightUpperLeg", "RightLowerLeg", "RightFoot"}
}

function Env.getPart(char, name)
    if not char then return nil end
    local p = char:FindFirstChild(name)
    if p then return p end
    local maps = Env.partMap[name]
    if maps then
        for _, n in ipairs(maps) do
            local part = char:FindFirstChild(n)
            if part then return part end
        end
    end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
end

function Env.isHeadshot(hitPart)
    if hitPart.Name == "Head" then return true end
    
    local char = hitPart:FindFirstAncestorOfClass("Model")
    if not char then return false end
    
    local head = char:FindFirstChild("Head")
    if not head then return false end
    
    if hitPart:IsA("Accessory") or hitPart:IsA("Hat") then
        local attachment = hitPart:FindFirstChildOfClass("Attachment")
        if attachment then
            local headAttachment = head:FindFirstChild(attachment.Name)
            if headAttachment then return true end
        end
    end
    
    if hitPart.Parent and hitPart.Parent:IsA("Accessory") then
        local accessory = hitPart.Parent
        local handle = accessory:FindFirstChild("Handle")
        if handle then
            local attachment = handle:FindFirstChildOfClass("Attachment")
            if attachment then
                local headAttachment = head:FindFirstChild(attachment.Name)
                if headAttachment then return true end
            end
        end
    end
    
    return false
end

function Env.getTargetPart(char)
    if not char then return nil end
    if Env.cfg.shieldbreaker then
        local shield = char:FindFirstChild("RiotShieldPart")
        if shield and shield:IsA("BasePart") then
            local hp = shield:GetAttribute("Health")
            if hp and hp > 0 then
                local myChar = LocalPlayer.Character
                local myHrp = myChar and myChar:FindFirstChild("HumanoidRootPart")
                local theirHrp = char:FindFirstChild("HumanoidRootPart")
                if myHrp and theirHrp then
                    local toMe = (myHrp.Position - theirHrp.Position).Unit
                    local theirLook = theirHrp.CFrame.LookVector
                    local dot = toMe:Dot(theirLook)
                    if dot > Env.cfg.shieldfrontangle then
                        if Env.cfg.shieldrandomhead and Env.vars.rng:NextInteger(1, 100) <= Env.cfg.shieldheadchance then
                            return Env.getPart(char, "Head")
                        end
                        return shield
                    end
                end
            end
        end
    end
    local partName
    if Env.cfg.randomparts then
        local list = Env.cfg.partslist
        partName = (list and #list > 0) and list[Env.vars.rng:NextInteger(1, #list)] or "Head"
    else
        partName = Env.cfg.aimpart
    end
    return Env.getPart(char, partName)
end

function Env.isDead(player)
    if not player or not player.Character then return true end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    return not humanoid or humanoid.Health <= 0
end

function Env.isStanding(player)
    if not player or not player.Character then return false end
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local vel = hrp.AssemblyLinearVelocity
    return Vector2.new(vel.X, vel.Z).Magnitude <= Env.cfg.stillthreshold
end

function Env.hasForceField(player)
    if not player or not player.Character then return false end
    return player.Character:FindFirstChildOfClass("ForceField") ~= nil
end

function Env.isInVehicle(player)
    if not player or not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    return humanoid.SeatPart ~= nil
end

function Env.wallBetween(startPos, endPos, targetChar)
    local myChar = LocalPlayer.Character
    if not myChar then return true end
    local filter = {myChar}
    if targetChar then table.insert(filter, targetChar) end
    Env.wallParams.FilterDescendantsInstances = filter
    local direction = endPos - startPos
    local distance = direction.Magnitude
    local unit = direction.Unit
    local currentStart = startPos
    local remaining = distance
    for _ = 1, 10 do
        local result = workspace:Raycast(currentStart, unit * remaining, Env.wallParams)
        if not result then return false end
        local hit = result.Instance
        if hit.Transparency < 0.8 and hit.CanCollide then return true end
        local hitDist = (result.Position - currentStart).Magnitude
        remaining = remaining - hitDist - 0.01
        if remaining <= 0 then return false end
        currentStart = result.Position + unit * 0.01
    end
    return false
end

function Env.quickCheck(player)
    if not player or player == LocalPlayer or not player.Character then return false end
    if not Env.getTargetPart(player.Character) then return false end
    if Env.cfg.deathcheck and Env.isDead(player) then return false end
    if Env.cfg.ffcheck and Env.hasForceField(player) then return false end
    if Env.cfg.vehiclecheck and Env.isInVehicle(player) then return false end
    if Env.cfg.teamcheck and player.Team == LocalPlayer.Team then return false end
    if Env.cfg.criminalsnoinnmates then
        if LocalPlayer.Team == Env.Teams.Criminals and player.Team == Env.Teams.Inmates then return false end
    end
    if Env.cfg.inmatesnocriminals then
        if LocalPlayer.Team == Env.Teams.Inmates and player.Team == Env.Teams.Criminals then return false end
    end
    if Env.cfg.hostilecheck or Env.cfg.trespasscheck then
        local isTaser = Env.vars.currentGun and Env.vars.currentGun:GetAttribute("Projectile") == "Taser"
        local bypassHostile = Env.cfg.taserbypasshostile and isTaser
        local bypassTrespass = Env.cfg.taserbypasstrespass and isTaser
        local targetChar = player.Character
        if LocalPlayer.Team == Env.Teams.Guards and player.Team == Env.Teams.Inmates then
            local hostile = targetChar:GetAttribute("Hostile")
            local trespass = targetChar:GetAttribute("Trespassing")
            if Env.cfg.hostilecheck and Env.cfg.trespasscheck then
                if not bypassHostile and not bypassTrespass then
                    if not hostile and not trespass then return false end
                end
            elseif Env.cfg.hostilecheck and not bypassHostile then
                if not hostile then return false end
            elseif Env.cfg.trespasscheck and not bypassTrespass then
                if not trespass then return false end
            end
        end
    end
    return true
end

function Env.fullCheck(player)
    if not Env.quickCheck(player) then return false end
    if Env.cfg.wallcheck then
        local myChar = LocalPlayer.Character
        local myHead = myChar and myChar:FindFirstChild("Head")
        local targetPart = Env.getTargetPart(player.Character)
        if myHead and targetPart then
            if Env.wallBetween(myHead.Position, targetPart.Position, player.Character) then
                return false
            end
        end
    end
    return true
end

function Env.rollHit()
    local now = os.clock()
    if now - Env.vars.lastShotTime > 0.15 then
        Env.vars.lastShotTime = now
        local chance = Env.cfg.hitchance
        if chance >= 100 then
            Env.vars.lastShotResult = true
        elseif chance <= 0 then
            Env.vars.lastShotResult = false
        else
            Env.vars.lastShotResult = Env.vars.rng:NextInteger(1, 100) <= chance
        end
    end
    return Env.vars.lastShotResult
end

function Env.getMissPos(targetPos)
    local spread = Env.cfg.missspread
    local angle = Env.vars.rng:NextNumber() * math.pi * 2
    local d = Env.vars.rng:NextNumber() * spread
    local yOffset = (Env.vars.rng:NextNumber() - 0.5) * spread
    return targetPos + Vector3.new(math.cos(angle) * d, yOffset, math.sin(angle) * d)
end

function Env.getClosest(fovRadius)
    fovRadius = fovRadius or Env.cfg.fov
    local camera = workspace.CurrentCamera
    if not camera then return nil, nil end

    local lastInput = Env.Services.UserInputService:GetLastInputType()
    local locked = (lastInput == Enum.UserInputType.Touch) or (Env.Services.UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)

    local aimPos
    if locked then
        local viewportSize = camera.ViewportSize
        aimPos = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    else
        aimPos = Env.Services.UserInputService:GetMouseLocation()
    end

    local now = os.clock()

    if Env.cfg.targetstickiness and Env.vars.currentTarget and (now - Env.vars.targetSwitchTime) < Env.vars.currentStickiness then
        if Env.fullCheck(Env.vars.currentTarget) then
            local part = Env.getTargetPart(Env.vars.currentTarget.Character)
            if part then
                local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
                if onScreen and screenPos.Z > 0 then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - aimPos).Magnitude
                    if dist < fovRadius then
                        return Env.vars.currentTarget, part.Position
                    end
                end
            end
        end
    end

    local candidates = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if Env.quickCheck(player) then
            local part = Env.getTargetPart(player.Character)
            if part then
                local screenPos, onScreen = camera:WorldToViewportPoint(part.Position)
                if onScreen and screenPos.Z > 0 then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - aimPos).Magnitude
                    if dist < fovRadius then
                        candidates[#candidates + 1] = {player = player, dist = dist, part = part}
                    end
                end
            end
        end
    end

    if Env.cfg.prioritizeclosest then
        table.sort(candidates, function(a, b) return a.dist < b.dist end)
    else
        for i = #candidates, 2, -1 do
            local j = Env.vars.rng:NextInteger(1, i)
            candidates[i], candidates[j] = candidates[j], candidates[i]
        end
    end

    for _, candidate in ipairs(candidates) do
        if Env.fullCheck(candidate.player) then
            if candidate.player ~= Env.vars.currentTarget then
                Env.vars.currentTarget = candidate.player
                Env.vars.targetSwitchTime = now
                if Env.cfg.targetstickinessrandom then
                    Env.vars.currentStickiness = Env.vars.rng:NextNumber(Env.cfg.targetstickinessmin, Env.cfg.targetstickinessmax)
                else
                    Env.vars.currentStickiness = Env.cfg.targetstickinessduration
                end
            end
            return candidate.player, candidate.part.Position
        end
    end

    Env.vars.currentTarget = nil
    return nil, nil
end

local Camera = workspace.CurrentCamera
local HitSound = Instance.new("Sound")
HitSound.Volume = Env.cfg.hitsound.volume
HitSound.Parent = Env.Services.SoundService

function Env.spawnHitmark(worldPos, isHead)
    if not Env.cfg.hitmarker.enabled then return end
    local screenPos, onScreen = Camera:WorldToViewportPoint(worldPos)
    if not onScreen then return end

    local gui = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
    local container = Instance.new("Frame", gui)
    container.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
    container.BackgroundTransparency = 1

    local conf = Env.cfg.hitmarker
    local color = isHead and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    local dist = isHead and conf.headExpand or conf.expand

    for i = 1, 4 do
        local angle = ({45, 135, 225, 315})[i]
        local line = Instance.new("Frame", container)
        line.BackgroundColor3 = color
        line.BorderSizePixel = 0
        line.Size = UDim2.new(0, conf.thickness, 0, conf.length)
        line.AnchorPoint = Vector2.new(0.5, 0)
        line.Rotation = angle
        
        local rad = math.rad(angle)
        line.Position = UDim2.new(0, math.sin(rad) * conf.gap, 0, -math.cos(rad) * conf.gap)
        
        Env.Services.TweenService:Create(line, TweenInfo.new(0.2), {
            Position = UDim2.new(0, math.sin(rad) * (conf.gap + dist), 0, -math.cos(rad) * (conf.gap + dist)),
            BackgroundTransparency = 1
        }):Play()
    end
    Env.Services.Debris:AddItem(gui, 0.25)
end

function Env.updateCrosshair()
    task.spawn(function()
        pcall(function()
            local gui = LocalPlayer.PlayerGui:FindFirstChild("CrosshairGui")
            if gui then
                local frame = gui:FindFirstChild("CrosshairFrame")
                if frame then
                    local dot = frame:FindFirstChild("Dot")
                    if dot and Env.cfg.crosshair.customImage ~= "" then
                        dot.Image = "rbxassetid://" .. Env.cfg.crosshair.customImage
                    end
                end
            end
        end)
    end)
end

function Env.getEquippedTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, v in ipairs(char:GetChildren()) do
        if v:IsA("Tool") then return v end
    end
    return nil
end

function Env.getMuzzlePosition()
    local tool = Env.getEquippedTool()
    if not tool then return nil end
    local muzzle = tool:FindFirstChild("Muzzle", true) or tool:FindFirstChild("MuzzleAttachment", true) or tool:FindFirstChild("Barrel", true)
    if muzzle then
        return muzzle:IsA("Attachment") and muzzle.WorldPosition or muzzle.Position
    end
    local handle = tool:FindFirstChild("Handle")
    return handle and handle.Position or nil
end

function Env.createTracer(fromPos, toPos)
    if not Env.cfg.tracer.enabled then return end
    local p0 = Instance.new("Part", workspace)
    p0.Anchored = true
    p0.CanCollide = false
    p0.Transparency = 1
    p0.Size = Vector3.new(0.1, 0.1, 0.1)
    p0.CFrame = CFrame.new(fromPos)
    
    local p1 = p0:Clone()
    p1.CFrame = CFrame.new(toPos)
    p1.Parent = workspace
    
    local a0 = Instance.new("Attachment", p0)
    local a1 = Instance.new("Attachment", p1)
    local beam = Instance.new("Beam", p0)
    beam.Attachment0 = a0
    beam.Attachment1 = a1
    beam.Color = ColorSequence.new(Env.cfg.tracer.color)
    beam.Width0 = Env.cfg.tracer.thickness
    beam.Width1 = Env.cfg.tracer.thickness
    beam.FaceCamera = true
    beam.LightEmission = 1
    
    task.delay(Env.cfg.tracer.lifetime, function()
        Env.Services.TweenService:Create(beam, TweenInfo.new(Env.cfg.tracer.fade), {Transparency = NumberSequence.new(1)}):Play()
    end)
    
    Env.Services.Debris:AddItem(p0, Env.cfg.tracer.lifetime + Env.cfg.tracer.fade + 0.1)
    Env.Services.Debris:AddItem(p1, Env.cfg.tracer.lifetime + Env.cfg.tracer.fade + 0.1)
end

local lastHitTime = 0
function Env.playHitsound(hitPart)
    if not Env.cfg.hitsound.enabled or not hitPart then return end
    local char = hitPart:FindFirstAncestorOfClass("Model")
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local plr = char and Players:GetPlayerFromCharacter(char)
    
    if hum and plr and plr ~= LocalPlayer and hum.Health > 0 then
        local now = tick()
        if now - lastHitTime < 0.05 then return end
        lastHitTime = now
        
        local isHead = Env.isHeadshot(hitPart)
        HitSound.SoundId = "rbxassetid://" .. (isHead and Env.cfg.hitsound.headshot or Env.cfg.hitsound.normal)
        HitSound:Play()
        
        Env.spawnHitmark(hitPart.Position, isHead)
    end
end

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    
    if method == "FireServer" and self.Name == "ShootEvent" and Env.cfg.enabled then
        task.spawn(function()
            local shots = args[1]
            if type(shots) ~= "table" then return end
            local muzzlePos = Env.getMuzzlePosition()
            if not muzzlePos then return end
            
            for i, shot in ipairs(shots) do
                if type(shot) == "table" and #shot >= 2 then
                    Env.createTracer(muzzlePos, shot[2])
                    if i == 1 and shot[3] then
                        Env.playHitsound(shot[3])
                    end
                end
            end
        end)
    end
    return old(self, ...)
end)

setreadonly(mt, true)



--]]

--[[ Part II(DEPENDENCY)

local Env = getgenv().PL_Hub

if not Env then
    return warn('Load Part 1 First!')
end

local Players = Env.Services.Players
local LocalPlayer = Players.LocalPlayer
local RunService = Env.Services.RunService
local Debris = Env.Services.Debris
local ReplicatedStorage = Env.Services.ReplicatedStorage
local fovCircle = Drawing.new('Circle')

fovCircle.Color = Color3.fromRGB(180, 120, 220)
fovCircle.Radius = Env.cfg.fov
fovCircle.Transparency = 0.5
fovCircle.Filled = false
fovCircle.NumSides = 64
fovCircle.Thickness = 1
fovCircle.Visible = Env.cfg.showfov and Env.cfg.enabled

local targetLine = Drawing.new('Line')

targetLine.Color = Color3.fromRGB(0, 255, 0)
targetLine.Thickness = 1
targetLine.Transparency = 0.5
targetLine.Visible = false

local visuals = {container = nil}
local espCache = {}

local function makeVisuals()
    local container

    if gethui then
        local screen = Instance.new('ScreenGui')

        screen.Name = 'SilentAimESP'
        screen.ResetOnSpawn = false
        screen.Parent = gethui()
        container = screen
    elseif syn and syn.protect_gui then
        local screen = Instance.new('ScreenGui')

        screen.Name = 'SilentAimESP'
        screen.ResetOnSpawn = false

        syn.protect_gui(screen)

        screen.Parent = Env.Services.CoreGui
        container = screen
    else
        local screen = Instance.new('ScreenGui')

        screen.Name = 'SilentAimESP'
        screen.ResetOnSpawn = false
        screen.Parent = Env.Services.CoreGui
        container = screen
    end

    visuals.container = container
end
local function makeEsp(player)
    if espCache[player] then
        return espCache[player]
    end

    local esp = Instance.new('BillboardGui')

    esp.Name = 'ESP_' .. player.Name
    esp.AlwaysOnTop = true
    esp.Size = UDim2.new(0, 20, 0, 20)
    esp.StudsOffset = Vector3.new(0, 3, 0)
    esp.LightInfluence = 0

    local diamond = Instance.new('Frame')

    diamond.Name = 'Diamond'
    diamond.BackgroundColor3 = Env.cfg.espcolor
    diamond.BorderSizePixel = 0
    diamond.Size = UDim2.new(0, 10, 0, 10)
    diamond.Position = UDim2.new(0.5, -5, 0.5, -5)
    diamond.Rotation = 45
    diamond.Parent = esp

    local stroke = Instance.new('UIStroke')

    stroke.Color = Color3.new(0, 0, 0)
    stroke.Thickness = 1.5
    stroke.Transparency = 0.3
    stroke.Parent = diamond

    local distLabel = Instance.new('TextLabel')

    distLabel.Name = 'DistanceLabel'
    distLabel.BackgroundTransparency = 1
    distLabel.Size = UDim2.new(0, 60, 0, 16)
    distLabel.Position = UDim2.new(0.5, -30, 1, 2)
    distLabel.Font = Enum.Font.GothamBold
    distLabel.TextSize = 11
    distLabel.TextColor3 = Color3.new(1, 1, 1)
    distLabel.TextStrokeTransparency = 0.5
    distLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    distLabel.Text = ''
    distLabel.Parent = esp

    local nameLabel = Instance.new('TextLabel')

    nameLabel.Name = 'NameLabel'
    nameLabel.BackgroundTransparency = 1
    nameLabel.Size = UDim2.new(0, 100, 0, 14)
    nameLabel.Position = UDim2.new(0.5, -50, 0, -16)
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextSize = 10
    nameLabel.TextColor3 = Color3.new(1, 1, 1)
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    nameLabel.Text = player.Name
    nameLabel.Parent = esp
    espCache[player] = esp

    return esp
end
local function removeEsp(player)
    local e = espCache[player]

    if e then
        e:Destroy()

        espCache[player] = nil
    end
end
local function shouldShowEsp(player)
    if not player or player == LocalPlayer or not player.Character then
        return false
    end

    local humanoid = player.Character:FindFirstChildOfClass('Humanoid')

    if not humanoid or humanoid.Health <= 0 then
        return false
    end

    local hrp = player.Character:FindFirstChild('HumanoidRootPart')

    if not hrp then
        return false
    end

    local myChar = LocalPlayer.Character

    if not myChar then
        return false
    end

    local myHrp = myChar:FindFirstChild('HumanoidRootPart')

    if not myHrp then
        return false
    end

    local distance = (hrp.Position - myHrp.Position).Magnitude

    if distance > Env.cfg.espmaxdist then
        return false
    end

    local myTeam = LocalPlayer.Team
    local theirTeam = player.Team

    if theirTeam == myTeam then
        if not Env.cfg.espshowteam then
            return false
        end

        return true
    end
    if Env.cfg.espteamcheck then
        local imCrimOrInmate = (myTeam == Env.Teams.Criminals or myTeam == Env.Teams.Inmates)
        local theyCrimOrInmate = (theirTeam == Env.Teams.Criminals or theirTeam == Env.Teams.Inmates)

        if imCrimOrInmate and theyCrimOrInmate then
            return false
        end
    end
    if theirTeam == Env.Teams.Guards then
        return Env.cfg.esptargets.guards
    elseif theirTeam == Env.Teams.Inmates then
        return Env.cfg.esptargets.inmates
    elseif theirTeam == Env.Teams.Criminals then
        return Env.cfg.esptargets.criminals
    end

    return false
end

Env.updateEsp = function()
    if not Env.cfg.esp or not visuals.container then
        for _, e in pairs(espCache)do
            e.Parent = nil
        end

        return
    end

    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild('HumanoidRootPart')

    for _, player in ipairs(Players:GetPlayers())do
        local show = shouldShowEsp(player)

        if show then
            local char = player.Character
            local hrp = char and char:FindFirstChild('HumanoidRootPart')
            local head = char and char:FindFirstChild('Head')

            if hrp and head then
                local esp = makeEsp(player)

                esp.Adornee = head
                esp.Parent = visuals.container

                local d = esp:FindFirstChild('Diamond')

                if d and Env.cfg.espuseteamcolors then
                    local t = player.Team

                    if t == LocalPlayer.Team then
                        d.BackgroundColor3 = Env.cfg.espteam
                    elseif t == Env.Teams.Guards then
                        d.BackgroundColor3 = Env.cfg.espguards
                    elseif t == Env.Teams.Inmates then
                        d.BackgroundColor3 = Env.cfg.espinmates
                    elseif t == Env.Teams.Criminals then
                        d.BackgroundColor3 = Env.cfg.espcriminals
                    else
                        d.BackgroundColor3 = Env.cfg.espcolor
                    end
                end
                if Env.cfg.espshowdist and myHrp then
                    local label = esp:FindFirstChild('DistanceLabel')

                    if label then
                        label.Text = math.floor((hrp.Position - myHrp.Position).Magnitude) .. 'm'
                        label.Visible = true
                    end
                end
            end
        else
            local e = espCache[player]

            if e then
                e.Parent = nil
            end
        end
    end
end

local c4espCache = {}

local function makeC4Esp(c4Part)
    if c4espCache[c4Part] then
        return c4espCache[c4Part]
    end

    local esp = Instance.new('BillboardGui')

    esp.Name = 'C4ESP_' .. tostring(c4Part)
    esp.AlwaysOnTop = true
    esp.Size = UDim2.new(0, 24, 0, 24)
    esp.StudsOffset = Vector3.new(0, 1, 0)

    local icon = Instance.new('Frame')

    icon.BackgroundColor3 = Env.cfg.c4espcolor
    icon.Size = UDim2.new(0, 14, 0, 14)
    icon.Position = UDim2.new(0.5, -7, 0.5, -7)
    icon.Rotation = 45
    icon.Parent = esp

    local label = Instance.new('TextLabel')

    label.BackgroundTransparency = 1
    label.Size = UDim2.new(0, 60, 0, 14)
    label.Position = UDim2.new(0.5, -30, 1, 2)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 11
    label.TextColor3 = Color3.new(1, 1, 1)
    label.Text = 'C4'
    label.Parent = esp

    local distLabel = Instance.new('TextLabel')

    distLabel.Name = 'DistLabel'
    distLabel.BackgroundTransparency = 1
    distLabel.Size = UDim2.new(0, 60, 0, 12)
    distLabel.Position = UDim2.new(0.5, -30, 1, 16)
    distLabel.Font = Enum.Font.GothamBold
    distLabel.TextSize = 10
    distLabel.TextColor3 = Env.cfg.c4espcolor
    distLabel.Text = ''
    distLabel.Parent = esp
    c4espCache[c4Part] = esp

    return esp
end

local trackedC4s = {}

local function isC4Part(part)
    if not part or not part:IsA('BasePart') then
        return false
    end

    local name = part.Name:lower()
    local parentName = part.Parent and part.Parent.Name:lower() or ''

    return name == 'explosive' or name == 'c4' or name == 'clientc4' or parentName:find('c4') or name:find('c4')
end
local function onDescendantAdded(desc)
    if isC4Part(desc) then
        trackedC4s[desc] = true
    end
end
local function onDescendantRemoving(desc)
    trackedC4s[desc] = nil

    if c4espCache[desc] then
        c4espCache[desc]:Destroy()

        c4espCache[desc] = nil
    end
end

for _, desc in ipairs(workspace:GetDescendants())do
    if isC4Part(desc) then
        trackedC4s[desc] = true
    end
end

workspace.DescendantAdded:Connect(onDescendantAdded)
workspace.DescendantRemoving:Connect(onDescendantRemoving)

Env.updateC4Esp = function()
    if not Env.cfg.c4esp or not visuals.container then
        for _, e in pairs(c4espCache)do
            e.Parent = nil
        end

        return
    end

    local myChar = LocalPlayer.Character
    local myHrp = myChar and myChar:FindFirstChild('HumanoidRootPart')

    for part in pairs(trackedC4s)do
        if part and part:IsDescendantOf(workspace) then
            local dist = myHrp and (part.Position - myHrp.Position).Magnitude or 0

            if dist <= Env.cfg.c4espmaxdist then
                local esp = makeC4Esp(part)

                esp.Adornee = part
                esp.Parent = visuals.container

                if Env.cfg.c4espshowdist and myHrp then
                    local distLabel = esp:FindFirstChild('DistLabel')

                    if distLabel then
                        distLabel.Text = math.floor(dist) .. 'm'
                    end
                end
            else
                if c4espCache[part] then
                    c4espCache[part].Parent = nil
                end
            end
        else
            trackedC4s[part] = nil

            if c4espCache[part] then
                c4espCache[part]:Destroy()

                c4espCache[part] = nil
            end
        end
    end
end

makeVisuals()

local ShootEvent = ReplicatedStorage:WaitForChild('GunRemotes'):WaitForChild('ShootEvent')
local lastAutoShoot = 0
local targetAcquiredTime = 0
local lastAutoTarget = nil
local cachedBulletsLabel = nil

local function createBulletTrail(startPos, endPos, isTaser)
    local distance = (endPos - startPos).Magnitude
    local trail = Instance.new('Part')

    trail.Name = 'BulletTrail'
    trail.Anchored = true
    trail.CanCollide = false
    trail.Material = Enum.Material.Neon
    trail.Size = Vector3.new(0.1, 0.1, distance)
    trail.CFrame = CFrame.new(startPos, endPos) * CFrame.new(0, 0, -distance / 2)
    trail.Transparency = 0.5

    if isTaser then
        trail.BrickColor = BrickColor.new('Cyan')
        trail.Size = Vector3.new(0.2, 0.2, distance)
    else
        trail.BrickColor = BrickColor.Yellow()
    end

    trail.Parent = workspace

    Debris:AddItem(trail, isTaser and 0.8 or 0.1)
end
local function autoShoot()
    if not Env.cfg.autoshoot or not Env.cfg.enabled or not Env.vars.currentGun then
        return
    end
    if Env.vars.currentGun:GetAttribute('Local_IsShooting') then
        return
    end
    if (Env.vars.currentGun:GetAttribute('Local_ReloadSession') or 0) > 0 then
        return
    end

    local now = os.clock()
    local fireRate = Env.vars.currentGun:GetAttribute('FireRate') or Env.cfg.autoshootdelay

    if now - lastAutoShoot < fireRate then
        return
    end

    local myChar = LocalPlayer.Character

    if not myChar then
        return
    end

    local myHead = myChar:FindFirstChild('Head')

    if not myHead then
        return
    end

    local muzzle = Env.vars.currentGun:FindFirstChild('Muzzle')
    local startPos = muzzle and muzzle.Position or myHead.Position
    local target, targetPos = Env.getClosest(Env.cfg.fov)

    if not target or not Env.fullCheck(target) then
        lastAutoTarget = nil

        return
    end
    if target ~= lastAutoTarget then
        targetAcquiredTime = now
        lastAutoTarget = target
    end
    if now - targetAcquiredTime < Env.cfg.autoshootstartdelay then
        return
    end

    local targetPart = Env.getTargetPart(target.Character)

    if not targetPart then
        return
    end

    local ammo = Env.vars.currentGun:GetAttribute('Local_CurrentAmmo') or Env.vars.currentGun:GetAttribute('CurrentAmmo') or 0

    if ammo <= 0 then
        return
    end

    lastAutoShoot = now

    local isTaser = Env.vars.currentGun:GetAttribute('Projectile') == 'Taser'
    local isShotgun = Env.vars.currentGun:GetAttribute('IsShotgun')
    local shouldHit = false

    if Env.cfg.taseralwayshit and isTaser then
        shouldHit = true
    elseif Env.cfg.ifplayerstill and Env.isStanding(target) then
        shouldHit = true
    elseif Env.cfg.hitchanceAutoOnly and isShotgun then
        shouldHit = true
    else
        shouldHit = Env.rollHit()
    end

    local projectileCount = Env.vars.currentGun:GetAttribute('ProjectileCount') or 1
    local shots = {}

    for i = 1, projectileCount do
        local finalPos

        if shouldHit then
            finalPos = targetPart.Position
        else
            if Env.cfg.missspread > 0 then
                finalPos = Env.getMissPos(targetPart.Position)
            else
                return
            end
        end

        shots[i] = {
            myHead.Position,
            finalPos,
            shouldHit and targetPart or nil,
        }

        createBulletTrail(startPos, finalPos, isTaser)
    end

    ShootEvent:FireServer(shots)

    local newAmmo = ammo - 1

    Env.vars.currentGun:SetAttribute('Local_CurrentAmmo', newAmmo)

    if not cachedBulletsLabel then
        local playerGui = LocalPlayer:FindFirstChild('PlayerGui')

        if playerGui then
            local home = playerGui:FindFirstChild('Home')

            if home and home:FindFirstChild('hud') then
                local br = home.hud:FindFirstChild('BottomRightFrame')

                if br and br:FindFirstChild('GunFrame') then
                    cachedBulletsLabel = br.GunFrame:FindFirstChild('BulletsLabel')
                end
            end
        end
    end
    if cachedBulletsLabel then
        cachedBulletsLabel.Text = newAmmo .. '/' .. (Env.vars.currentGun:GetAttribute('MaxAmmo') or 30)
    end

    local handle = Env.vars.currentGun:FindFirstChild('Handle')

    if handle and handle:FindFirstChild('ShootSound') then
        local sound = handle.ShootSound:Clone()

        sound.Parent = handle

        sound:Play()
        Debris:AddItem(sound, 2)
    end
end
local function getGun()
    local char = LocalPlayer.Character

    if not char then
        return nil
    end

    for _, tool in ipairs(char:GetChildren())do
        if tool:IsA('Tool') and tool:GetAttribute('ToolType') == 'Gun' then
            return tool
        end
    end

    return nil
end

local lastGun = nil

RunService.Heartbeat:Connect(function()
    Env.vars.currentGun = getGun()

    if Env.vars.currentGun ~= lastGun then
        lastAutoShoot = 0
        lastGun = Env.vars.currentGun
    end

    autoShoot()
end)
RunService.PreRender:Connect(function()
    local aimPos = Env.Services.UserInputService:GetMouseLocation()
    local camera = workspace.CurrentCamera

    if camera then
        local lastInput = Env.Services.UserInputService:GetLastInputType()
        local locked = (lastInput == Enum.UserInputType.Touch) or (Env.Services.UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter)

        if locked then
            local viewportSize = camera.ViewportSize

            aimPos = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
        end
    end

    fovCircle.Position = aimPos
    fovCircle.Radius = Env.cfg.fov
    fovCircle.Visible = Env.cfg.showfov and Env.cfg.enabled

    if Env.cfg.showtargetline and Env.cfg.enabled then
        local target, targetPos = Env.getClosest()

        if target and targetPos and camera then
            local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)

            if onScreen then
                targetLine.From = aimPos
                targetLine.To = Vector2.new(screenPos.X, screenPos.Y)
                targetLine.Visible = true
            else
                targetLine.Visible = false
            end
        else
            targetLine.Visible = false
        end
    else
        targetLine.Visible = false
    end

    Env.updateEsp()
    Env.updateC4Esp()
end)
Players.PlayerRemoving:Connect(removeEsp)
LocalPlayer:GetPropertyChangedSignal('Team'):Connect(function()
    for player, e in pairs(espCache)do
        if e then
            e:Destroy()
        end

        espCache[player] = nil
    end
end)

local origCastRay
local hooked = false

local function setupHook()
    local castRayFunc = filtergc('function', {
        Name = 'castRay',
    }, true)

    if not castRayFunc then
        return false
    end

    origCastRay = hookfunction(castRayFunc, function(startPos, targetPos, ...)
        if not Env.cfg.enabled then
            return origCastRay(startPos, targetPos, ...)
        end

        local closest, closestPos = Env.getClosest(Env.cfg.fov)

        if closest and closest.Character then
            local isTaser = Env.vars.currentGun and Env.vars.currentGun:GetAttribute('Projectile') == 'Taser'
            local isShotgun = Env.vars.currentGun and Env.vars.currentGun:GetAttribute('IsShotgun')
            local shouldHit = false

            if Env.cfg.hitchanceAutoOnly and isShotgun then
                return origCastRay(startPos, targetPos, ...)
            end
            if Env.cfg.shotgungamehandled and isShotgun then
                local targetPart = Env.getTargetPart(closest.Character)

                if targetPart then
                    return origCastRay(startPos, targetPart.Position, ...)
                end

                return origCastRay(startPos, targetPos, ...)
            end
            if Env.cfg.taseralwayshit and isTaser then
                shouldHit = true
            elseif Env.cfg.ifplayerstill and Env.isStanding(closest) then
                shouldHit = true
            else
                shouldHit = Env.rollHit()
            end
            if shouldHit then
                local targetPart = Env.getTargetPart(closest.Character)

                if targetPart then
                    if Env.cfg.shotgunnaturalspread and isShotgun then
                        return origCastRay(startPos, targetPart.Position, ...)
                    end

                    return targetPart, targetPart.Position
                end
            else
                if Env.cfg.missspread > 0 then
                    local targetPart = Env.getTargetPart(closest.Character)

                    if targetPart then
                        local missPos = Env.getMissPos(targetPart.Position)

                        return origCastRay(startPos, missPos, ...)
                    end
                end

                return origCastRay(startPos, targetPos, ...)
            end
        end

        return origCastRay(startPos, targetPos, ...)
    end)

    return true
end

if not setupHook() then
    task.spawn(function()
        while not hooked do
            task.wait(0.5)

            if setupHook() then
                hooked = true
            end
        end
    end)
else
    hooked = true
end



--]]

--[[ VehicleMods (Feature-baesd)

local Env = getgenv().PL_Hub
if not Env then return warn("Load main hub first!") end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

-- Vehicle configuration
if not Env.cfg.vehicle then
    Env.cfg.vehicle = {
        enabled = false,
        maxSpeed = 100,
        turnSpeed = 2,
        torque = 100,
        steerFloat = 1,
        fly = false,
        flySpeed = 1,
    }
end

-- Vehicle references
local currentVehicle = nil
local originalVehicleStats = {}
local vehicleConnection = nil
local FLYING = false
local flyKeyDown = nil
local flyKeyUp = nil
local flyLoop = nil
local BG = nil
local BV = nil

-- Mobile detection
local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Find vehicle seat
local function findVehicle()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid and humanoid.SeatPart and humanoid.SeatPart:IsA("VehicleSeat") then
        return humanoid.SeatPart
    end
    return nil
end

-- Get root part of vehicle
local function getVehicleRoot()
    if not currentVehicle then return nil end
    local vehicleModel = currentVehicle.Parent
    if not vehicleModel then return nil end
    return vehicleModel.PrimaryPart or vehicleModel:FindFirstChild("Main") or vehicleModel:FindFirstChild("Body") or currentVehicle
end

-- Apply vehicle modifications
local function applyVehicleMods(vehicle)
    if not vehicle or not Env.cfg.vehicle.enabled then return end
    
    if not originalVehicleStats[vehicle] then
        originalVehicleStats[vehicle] = {
            MaxSpeed = vehicle.MaxSpeed,
            TurnSpeed = vehicle.TurnSpeed,
            Torque = vehicle.Torque,
            Steer = vehicle.Steer
        }
    end
    
    vehicle.MaxSpeed = Env.cfg.vehicle.maxSpeed
    vehicle.TurnSpeed = Env.cfg.vehicle.turnSpeed
    vehicle.Torque = Env.cfg.vehicle.torque
    vehicle.Steer = Env.cfg.vehicle.steerFloat
end

-- Stop fly
local function stopVehicleFly()
    print("[VFly] Stopping...")
    FLYING = false
    
    -- Disconnect fly loop
    if flyLoop then
        flyLoop:Disconnect()
        flyLoop = nil
    end
    
    -- Disconnect input handlers
    if flyKeyDown then
        flyKeyDown:Disconnect()
        flyKeyDown = nil
    end
    if flyKeyUp then
        flyKeyUp:Disconnect()
        flyKeyUp = nil
    end
    
    -- Destroy BodyMovers
    if BG then
        BG:Destroy()
        BG = nil
    end
    if BV then
        BV:Destroy()
        BV = nil
    end
    
    -- Remove mobile UI
    local gui = LocalPlayer.PlayerGui:FindFirstChild("VehicleFlyMobileUI")
    if gui then gui:Destroy() end
    
    pcall(function()
        workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end)
end

-- Vehicle Fly (Infinite Yield style)
local function startVehicleFly()
    print("[VFly] Starting...")
    
    local T = getVehicleRoot()
    if not T then 
        warn("[VFly] No root found!")
        return 
    end
    
    print("[VFly] Using:", T.Name)
    
    -- Stop existing fly
    stopVehicleFly()
    
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0
    
    FLYING = true
    BG = Instance.new('BodyGyro')
    BV = Instance.new('BodyVelocity')
    BG.P = 9e4
    BG.Parent = T
    BV.Parent = T
    BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    BG.cframe = T.CFrame
    BV.velocity = Vector3.new(0, 0, 0)
    BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
    
    -- Fly loop
    flyLoop = RunService.Heartbeat:Connect(function()
        if not FLYING or not Env.cfg.vehicle.fly or not T.Parent then
            stopVehicleFly()
            return
        end
        
        if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
            SPEED = 50
        elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
            SPEED = 0
        end
        
        if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
            BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
            lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
        elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
            BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
        else
            BV.velocity = Vector3.new(0, 0, 0)
        end
        
        BG.cframe = workspace.CurrentCamera.CoordinateFrame
    end)
    
    -- Keyboard controls
    flyKeyDown = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        local KEY = input.KeyCode
        
        if KEY == Enum.KeyCode.W then
            CONTROL.F = Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.S then
            CONTROL.B = -Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.A then
            CONTROL.L = -Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.D then
            CONTROL.R = Env.cfg.vehicle.flySpeed
        elseif KEY == Enum.KeyCode.E then
            CONTROL.Q = Env.cfg.vehicle.flySpeed * 2
        elseif KEY == Enum.KeyCode.Q then
            CONTROL.E = -Env.cfg.vehicle.flySpeed * 2
        end
    end)
    
    flyKeyUp = UserInputService.InputEnded:Connect(function(input)
        local KEY = input.KeyCode
        
        if KEY == Enum.KeyCode.W then
            CONTROL.F = 0
        elseif KEY == Enum.KeyCode.S then
            CONTROL.B = 0
        elseif KEY == Enum.KeyCode.A then
            CONTROL.L = 0
        elseif KEY == Enum.KeyCode.D then
            CONTROL.R = 0
        elseif KEY == Enum.KeyCode.E then
            CONTROL.Q = 0
        elseif KEY == Enum.KeyCode.Q then
            CONTROL.E = 0
        end
    end)
    
    -- Mobile joystick support
    if isMobile then
        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            task.spawn(function()
                while FLYING do
                    local moveVector = humanoid.MoveVector
                    
                    -- Convert joystick input to fly controls
                    CONTROL.F = moveVector.Z < 0 and (-moveVector.Z * Env.cfg.vehicle.flySpeed) or 0
                    CONTROL.B = moveVector.Z > 0 and (-moveVector.Z * Env.cfg.vehicle.flySpeed) or 0
                    CONTROL.L = moveVector.X < 0 and (moveVector.X * Env.cfg.vehicle.flySpeed) or 0
                    CONTROL.R = moveVector.X > 0 and (moveVector.X * Env.cfg.vehicle.flySpeed) or 0
                    
                    task.wait(0.05)
                end
            end)
        end
        
        -- Create mobile up/down buttons
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "VehicleFlyMobileUI"
        screenGui.ResetOnSpawn = false
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.Parent = LocalPlayer.PlayerGui
        
        local function createButton(name, position, text)
            local btn = Instance.new("TextButton")
            btn.Name = name
            btn.Size = UDim2.new(0, 70, 0, 70)
            btn.Position = position
            btn.BackgroundColor3 = NebulaStorm.ElementBackground
            btn.BackgroundTransparency = 0.3
            btn.Text = text
            btn.TextColor3 = NebulaStorm.TextColor
            btn.TextSize = 24
            btn.Font = Enum.Font.GothamBold
            btn.ZIndex = 300
            btn.Parent = screenGui
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 12)
            corner.Parent = btn
            
            return btn
        end
        
        local upBtn = createButton("Up", UDim2.new(1, -85, 1, -230), "")
        local downBtn = createButton("Down", UDim2.new(1, -85, 1, -150), "")
        
        upBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.Q = Env.cfg.vehicle.flySpeed * 2
                upBtn.BackgroundColor3 = NebulaStorm.SliderProgress
            end
        end)
        
        upBtn.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.Q = 0
                upBtn.BackgroundColor3 = NebulaStorm.ElementBackground
            end
        end)
        
        downBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.E = -Env.cfg.vehicle.flySpeed * 2
                downBtn.BackgroundColor3 = NebulaStorm.SliderProgress
            end
        end)
        
        downBtn.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch then
                CONTROL.E = 0
                downBtn.BackgroundColor3 = NebulaStorm.ElementBackground
            end
        end)
    end
    
    print("[VFly] Started successfully!")
end

-- Stop vehicle monitoring
local function stopVehicleMonitoring()
    if vehicleConnection then
        vehicleConnection:Disconnect()
        vehicleConnection = nil
    end
    
    stopVehicleFly()
    
    if currentVehicle and originalVehicleStats[currentVehicle] then
        local stats = originalVehicleStats[currentVehicle]
        pcall(function()
            currentVehicle.MaxSpeed = stats.MaxSpeed
            currentVehicle.TurnSpeed = stats.TurnSpeed
            currentVehicle.Torque = stats.Torque
            currentVehicle.Steer = stats.Steer
        end)
    end
    
    currentVehicle = nil
end

-- Monitor vehicle state
local function startVehicleMonitoring()
    if vehicleConnection then
        vehicleConnection:Disconnect()
    end
    
    vehicleConnection = RunService.Heartbeat:Connect(function()
        local vehicle = findVehicle()
        
        if vehicle ~= currentVehicle then
            currentVehicle = vehicle
            if vehicle then
                applyVehicleMods(vehicle)
                if Env.cfg.vehicle.fly then
                    task.wait(0.1)
                    startVehicleFly()
                end
            else
                stopVehicleFly()
            end
        end
        
        if currentVehicle then
            applyVehicleMods(currentVehicle)
        end
    end)
end

-- Handle character respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    if Env.cfg.vehicle and Env.cfg.vehicle.enabled then
        task.wait(1)
        startVehicleMonitoring()
    end
end)

-- Start monitoring if enabled
if Env.cfg.vehicle and Env.cfg.vehicle.enabled then
    startVehicleMonitoring()
end

-- Export functions to global environment
getgenv().startVehicleMonitoring = startVehicleMonitoring
getgenv().stopVehicleMonitoring = stopVehicleMonitoring
getgenv().startVehicleFly = startVehicleFly
getgenv().stopVehicleFly = stopVehicleFly
getgenv().getCurrentVehicle = function() return currentVehicle end

-- ============================================================================
-- STARTUP EFFECTS
-- ============================================================================

task.wait(0.3)
FX:Sound(Assets.Sounds.PowerUp, 0.7, 1)

print("[Casual Comas] Flashy Theme loaded successfully!")

--]]

